<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="1. 中断设计constrains 中断应该是尽量能够快速响应的，否则类似网络传输的数据可能丢失 因此linux将中断处理设计成了urgent的部分+可以defer处理的部分    中断处理必须考虑重入问题，在处理一个中断时候处理其他中断 中断可以被屏蔽的，disabled  2. 中断和异常中断(interrupt)  可屏蔽中断(Maskable interrupts) 所有Device触发的">
<meta name="keywords" content="Micro,Linux,Interrupt">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Interrupt Part 1">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;05&#x2F;Linux-Interrupt-Part-1&#x2F;index.html">
<meta property="og:site_name" content="梅子黄时雨">
<meta property="og:description" content="1. 中断设计constrains 中断应该是尽量能够快速响应的，否则类似网络传输的数据可能丢失 因此linux将中断处理设计成了urgent的部分+可以defer处理的部分    中断处理必须考虑重入问题，在处理一个中断时候处理其他中断 中断可以被屏蔽的，disabled  2. 中断和异常中断(interrupt)  可屏蔽中断(Maskable interrupts) 所有Device触发的">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-12-16T15:09:22.958Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2019/12/05/Linux-Interrupt-Part-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Linux Interrupt Part 1 | 梅子黄时雨</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">梅子黄时雨</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/05/Linux-Interrupt-Part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux Interrupt Part 1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-05 22:49:18" itemprop="dateCreated datePublished" datetime="2019-12-05T22:49:18+08:00">2019-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-16 23:09:22" itemprop="dateModified" datetime="2019-12-16T23:09:22+08:00">2019-12-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-中断设计constrains"><a href="#1-中断设计constrains" class="headerlink" title="1. 中断设计constrains"></a>1. 中断设计constrains</h1><ul>
<li>中断应该是尽量能够快速响应的，否则类似网络传输的数据可能丢失<ul>
<li>因此linux将中断处理设计成了urgent的部分+可以defer处理的部分 </li>
</ul>
</li>
<li>中断处理必须考虑重入问题，在处理一个中断时候处理其他中断</li>
<li>中断可以被屏蔽的，disabled</li>
</ul>
<h1 id="2-中断和异常"><a href="#2-中断和异常" class="headerlink" title="2. 中断和异常"></a>2. 中断和异常</h1><p>中断(interrupt)</p>
<ul>
<li>可屏蔽中断(Maskable interrupts)<ul>
<li>所有Device触发的Interrupt Requests(IRQs)都是可屏蔽中断</li>
</ul>
</li>
<li>不可屏蔽中断(Nonmaskable interrupts)<ul>
<li>一些重要的events(比如硬件故障)是不可屏蔽中断</li>
</ul>
</li>
</ul>
<p>异常(exception)</p>
<ul>
<li><p>Processor-detected exceptions: Generated when the CPU detects an anomalous condition when execution instruction. 进一步的细分成三种：</p>
<ul>
<li>Faults: 可恢复，返回当前运行的指令。跳转到前的指令存在EIP中</li>
<li>Traps: 回到下一条指令继续运行</li>
<li>Aborts: process只能被terminated，不过可以在这里检索错误现场</li>
</ul>
</li>
<li><p>可编程的异常(Programmed exceptions):  Occur at the request of the programmer.</p>
<ul>
<li>比如INT指令或者INT 3</li>
<li>into或者bound指令失败时候也会触发</li>
<li>一般被叫做software interrupts</li>
<li>一般用作系统调用或者debug</li>
</ul>
</li>
</ul>
<p>所有中断和异常使用unsigned 8bits来作为index，这个值被intel称为vector。</p>
<h1 id="3-IRQs-and-Interrupts"><a href="#3-IRQs-and-Interrupts" class="headerlink" title="3. IRQs and Interrupts"></a>3. IRQs and Interrupts</h1><p>所有的device controller都可以被指定一条或者多条Interrupt<br> ReQest(IRQ) line. 所有existing IRQ lines都被绑定到专用硬件的input pins上。这个硬件叫Programmable Interrupt Controller(可编程中断控制器)。</p>
<p> PIC的具体流程如下：</p>
<ol>
<li>检测所有连接的IRQ lines是否有raised signals。如果有多个IRQ lines被raised，那么选择lower pin的number。</li>
<li>如果有IRQ line被raise<ul>
<li>convert raised signal to对应的vector</li>
<li>将vector保存在一个Interrupt Controller I/O port，这使得cpu可以通过data bus读到这个vector</li>
<li>send一个raised signal到CPU的INTR pin，触发一个中断</li>
<li>等待cpu acknowldege the interrupt signal by writting into one of the Programmable Interrupt Controllers(PIC) I/O ports. 在此之后，clear INTR line.</li>
</ul>
<ol>
<li>回到step 1</li>
</ol>
</li>
</ol>
<p>IRQ定义从0开始，也就是IRQ0，对应的intel的vector值从32开始。但是具体的对应的关系，是可以通过编程来定义的。</p>
<p>IRQ的line是可以选择性的ignored，但是对应的signal不会被丢失，会在un-ingore时候触发该有的操作。</p>
<p>注意，这里的ignore和可屏蔽的中断的屏蔽是两个概念。EFLAGS中的IF flag的屏蔽和恢复(cli and sti)都是针对于所有IRQ lines。</p>
<p>最早的PIC设备是2片8259A芯片，支持15个IRQs(主片的IRQ2 pin接到了从片上)。同时8259A芯片不支持多核（SMP）。</p>
<h1 id="4-APIC-Advanced-Programmable-Interrupt-Controller"><a href="#4-APIC-Advanced-Programmable-Interrupt-Controller" class="headerlink" title="4. APIC (Advanced Programmable Interrupt Controller)"></a>4. APIC (Advanced Programmable Interrupt Controller)</h1><p>为了支持SMP，引入了APIC，包括：</p>
<ul>
<li>local APIC，包含LINT0和LINT1两个pin接口，在模拟8259A芯片时候，可以一个作为INTR，一个作为NMI。</li>
<li>I/O APIC，作为对接设备的LB存在，负责接收device， controller的singal，然后负责分发。也能模拟8259A芯片。</li>
<li>可编程，提供复杂的IRQ和vector的映射关系</li>
<li>同时通过各自的Interrupt Command Register(ICR)，各个core之间也可以相互发送消息（中断），称为interprocessor interrupt (IPIs)</li>
<li>I/O APIC的分发可以是static的（类似affinity），也可以使用round robin的方式。</li>
</ul>
<h1 id="5-Required-Exceptions"><a href="#5-Required-Exceptions" class="headerlink" title="5. Required Exceptions"></a>5. Required Exceptions</h1><p>vector最小的一系列exception(0-19)是intel定义，并且每个os都必须又对应的handler进行处理的。linux对于这些exception，每个注册了对应的exeption handler，这些handler大部分最终会send相对应的SIGNAL来方便其他程序监听和处理。比较有意思的几个如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Exception</th>
<th>Exception handler</th>
<th>Signal</th>
</tr>
</thead>
<tbody>
<tr>
<td>14</td>
<td>Page Fault</td>
<td>page_fault( )</td>
<td>SIGSEGV</td>
</tr>
<tr>
<td>17</td>
<td>Alignment</td>
<td>check alignment_check( )</td>
<td>SIGBUS</td>
</tr>
</tbody>
</table>
</div>
<h1 id="6-IDT"><a href="#6-IDT" class="headerlink" title="6. IDT"></a>6. IDT</h1><p>IDT中可以保存三类gate：</p>
<ul>
<li><strong>Task Gate</strong>：保存了一个TSS的段选择器，简单来说就是当这个exception handler被触发时候，会发生task的切换来进行处理</li>
<li><strong>Interrupt Gate</strong>：保存普通的段选择器+offset，用来指向对应的处理代码入口；Interrupt Gate触发时候会clear IF flag来屏蔽中断。</li>
<li><strong>Trap Gate</strong>：和Interrupt Gate一样，保存普通的段选择器+offset，但是不会屏蔽中断</li>
</ul>
<p>总体来说，Linux uses interrupt gates to handle interrupts and trap gates to handle exceptions.</p>
<h1 id="7-Interrupt-Trigger-Process"><a href="#7-Interrupt-Trigger-Process" class="headerlink" title="7. Interrupt Trigger Process"></a>7. Interrupt Trigger Process</h1><p>Trigger process</p>
<ol>
<li>从GDTR获取GDT的信息，然后取得对应的段描述符</li>
<li>比较权限，需要满足下述条件，否则throw “General Protection”:<ul>
<li>对于非用户触发的Interrupt，CPL &lt;= DPL，也就是说interrupt handler权限要不小于触发中断的程序的权限，否则无法进行处理中断。</li>
<li>对于用户触发的Interrupt，需要CPL =&gt; DPL，也就是说用户的权限要不小于触发的handler的权限，否则用户可以去调用其他的interrupt或者trap gate。</li>
</ul>
</li>
<li>如果CPL和DPL的权限不同，那就需要切换到DPL对应级别的TSS和Stack上<ul>
<li>首先读取当前的ss和esp信息（当前stack信息）</li>
<li>从需要切换到对象的TSS中读取对应的ss和esp信息</li>
<li>将当前的ss和esp信息保存在切换后的stack中</li>
</ul>
</li>
<li>如果是fault，那么需要同时需要保存cs和eip，等待handler后返回现场（逻辑地址）；最后保存eflags。如果有hardware error code，同样保存在stack上。</li>
<li>从段描述符中读取基地址，加上offset，得到目标逻辑地址并设置cs和eip，开始执行interrupt handler。</li>
</ol>
<p>在interrupt handler完成工作后，需要返回到原有的进程中，一般通过iret命令，其包括如下的操作：</p>
<ol>
<li>从当前stack上获取cs，eip和eflags。</li>
<li>如果权限之前发生过切换，那么需要恢复到原有的stack上，ss和esp同样保存在interrupt handler的stack上</li>
<li>恢复stack，恢复cs，eip和eflags</li>
<li>检查ds，es，fs和gs的DPL是否小于恢复后的CPL，如果是，那么进行清空。这是以防用户进程获取的系统权限级别的段描述符。</li>
</ol>
<h1 id="8-Interrupt-Gate"><a href="#8-Interrupt-Gate" class="headerlink" title="8. Interrupt Gate"></a>8. Interrupt Gate</h1><p>Gate类型：</p>
<ul>
<li><strong>Interrupt gate</strong><ul>
<li>DPL = 0</li>
<li>处理内部的中断(interrupt)</li>
</ul>
</li>
<li><strong>System gate</strong><ul>
<li>DPL = 3</li>
<li>vector 4(into), 5(bound)和128(int 0x80)使用这个gate</li>
</ul>
</li>
<li><strong>System interrupt gate</strong><ul>
<li>DPL = 3</li>
<li>int3, User Mode的Debug</li>
</ul>
</li>
<li><strong>Trap gate</strong><ul>
<li>DPL = 0</li>
<li>大部分内部异常(exception)依赖于这个</li>
</ul>
</li>
<li><strong>Task gate</strong><ul>
<li>DPL = 0</li>
<li>handle double fault</li>
</ul>
</li>
</ul>
<h1 id="9-IDT初始化"><a href="#9-IDT初始化" class="headerlink" title="9. IDT初始化"></a>9. IDT初始化</h1><p>5.4 kernel中和UTLK中的实现已经有所不同了</p>
<h2 id="9-1-legacy-mode"><a href="#9-1-legacy-mode" class="headerlink" title="9.1. legacy mode"></a>9.1. legacy mode</h2><p>在4.x版本中，初始化依然是通过”函数”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">oid __init trap_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	set_intr_gate(X86_TRAP_DE, divide_error);</span><br><span class="line">	set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);</span><br><span class="line">	/* int4 can be called from all */</span><br><span class="line">	set_system_intr_gate(X86_TRAP_OF, &amp;overflow);</span><br><span class="line">	set_intr_gate(X86_TRAP_BR, bounds);</span><br><span class="line">	set_intr_gate(X86_TRAP_UD, invalid_op);</span><br><span class="line">	set_intr_gate(X86_TRAP_NM, device_not_available);</span><br><span class="line">#ifdef CONFIG_X86_32</span><br><span class="line">	set_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);</span><br><span class="line">#else</span><br><span class="line">	set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set_intr_gate负责设置interrupt gate：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set_intr_gate(n, addr)</span><br><span class="line"> |- set_intr_gate_notrace(n, addr);</span><br><span class="line">    |- _set_gate(n, GATE_INTERRUPT, (<span class="keyword">void</span> *)addr, <span class="number">0</span>, <span class="number">0</span>, __KERNEL_CS);</span><br><span class="line">       |- pack_gate(&amp;s, type, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr, dpl, ist, seg);</span><br><span class="line">       |- write_idt_entry(idt_table, gate, &amp;s);</span><br><span class="line">       |- write_trace_idt_entry(gate, &amp;s); <span class="comment">// trace</span></span><br><span class="line">  |- _trace_set_gate  <span class="comment">// linux trace</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// write</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_idt_entry(dt, entry, g)		native_write_idt_entry(dt, entry, g)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">native_write_idt_entry</span><span class="params">(gate_desc *idt, <span class="keyword">int</span> entry, <span class="keyword">const</span> gate_desc *gate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;idt[entry], gate, <span class="keyword">sizeof</span>(*gate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到set_intr_gate等一些列操作，最终是往内存的一个位置(idt_table)写入对应的gate信息。</p>
<p>idt_table在head_32.S中被定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idt_descr:</span><br><span class="line">	.word IDT_ENTRIES*8-1		# idt contains 256 entries</span><br><span class="line">	.long idt_table</span><br></pre></td></tr></table></figure>
<p>对于64bit的定义在arch/x86/kernel/cpu/common.c中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line">struct desc_ptr idt_descr __ro_after_init = &#123;</span><br><span class="line">	.size = NR_VECTORS * 16 - 1,</span><br><span class="line">	.address = (unsigned long) idt_table,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>随后会被lidt命令把地址写入idtr中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The load_current_idt() must be called with interrupts disabled</span><br><span class="line"> * to avoid races. That way the IDT will always be set back to the expected</span><br><span class="line"> * descriptor. It&apos;s also called when a CPU is being initialized, and</span><br><span class="line"> * that doesn&apos;t need to disable interrupts, as nothing should be</span><br><span class="line"> * bothering the CPU then.</span><br><span class="line"> */</span><br><span class="line">static inline void load_current_idt(void)</span><br><span class="line">&#123;</span><br><span class="line">	if (is_debug_idt_enabled())</span><br><span class="line">		load_debug_idt();</span><br><span class="line">	else if (is_trace_idt_enabled())</span><br><span class="line">		load_trace_idt();</span><br><span class="line">	else</span><br><span class="line">		load_idt((const struct desc_ptr *)&amp;idt_descr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而lidt的会读取desc_ptr struct的size作为limit，address作为idt的base：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IF OperandSize = 16</span><br><span class="line">    THEN</span><br><span class="line">        IDTR(Limit) ← SRC[0:15];</span><br><span class="line">        IDTR(Base) ← SRC[16:47] AND 00FFFFFFH;</span><br><span class="line">    ELSE IF 32-bit Operand Size</span><br><span class="line">        THEN</span><br><span class="line">            IDTR(Limit) ← SRC[0:15];</span><br><span class="line">            IDTR(Base) ← SRC[16:47];</span><br><span class="line">        FI;</span><br><span class="line">    ELSE IF 64-bit Operand Size (* In 64-Bit Mode *)</span><br><span class="line">        THEN</span><br><span class="line">            IDTR(Limit) ← SRC[0:15];</span><br><span class="line">            IDTR(Base) ← SRC[16:79];</span><br><span class="line">        FI;</span><br><span class="line">FI;</span><br></pre></td></tr></table></figure>
<h2 id="9-2-kernel-version-5-4"><a href="#9-2-kernel-version-5-4" class="headerlink" title="9.2. kernel version 5.4"></a>9.2. kernel version 5.4</h2><p>5.4 kernel中初始化有改变，set_intr_gate没有了，或者说设置default idt的值不通过set_intr_gate。不过idt_table之类的还是在的，依旧做为idt的内存存储：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The default IDT entries which are set up in trap_init() before</span><br><span class="line"> * cpu_init() is invoked. Interrupt stacks cannot be used at that point and</span><br><span class="line"> * the traps which use them are reinitialized with IST after cpu_init() has</span><br><span class="line"> * set up TSS.</span><br><span class="line"> */</span><br><span class="line">static const __initconst struct idt_data def_idts[] = &#123;</span><br><span class="line">	INTG(X86_TRAP_DE,		divide_error),</span><br><span class="line">	INTG(X86_TRAP_NMI,		nmi),</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_X86_32</span><br><span class="line">	TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),</span><br><span class="line">#else</span><br><span class="line">	INTG(X86_TRAP_DF,		double_fault),</span><br><span class="line">#endif</span><br><span class="line">	INTG(X86_TRAP_DB,		debug),</span><br><span class="line"></span><br><span class="line">	SYSG(X86_TRAP_OF,		overflow),</span><br><span class="line">#if defined(CONFIG_IA32_EMULATION)</span><br><span class="line">	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),</span><br><span class="line">#elif defined(CONFIG_X86_32)</span><br><span class="line">	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，set_intr_gate变成了INTG的宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define G(_vector, _addr, _ist, _type, _dpl, _segment)	\</span><br><span class="line">	&#123;						\</span><br><span class="line">		.vector		= _vector,		\</span><br><span class="line">		.bits.ist	= _ist,			\</span><br><span class="line">		.bits.type	= _type,		\</span><br><span class="line">		.bits.dpl	= _dpl,			\</span><br><span class="line">		.bits.p		= 1,			\</span><br><span class="line">		.addr		= _addr,		\</span><br><span class="line">		.segment	= _segment,		\</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">/* Interrupt gate */</span><br><span class="line">#define INTG(_vector, _addr)				\</span><br><span class="line">	G(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL0, __KERNEL_CS)</span><br></pre></td></tr></table></figure>
<p>这里的idt_data定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct idt_data &#123;</span><br><span class="line">	unsigned int	vector;</span><br><span class="line">	unsigned int	segment;</span><br><span class="line">	struct idt_bits	bits;</span><br><span class="line">	const void	*addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而def_idts的值会在函数idt_setup_from_table中写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">idt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)</span><br><span class="line">&#123;</span><br><span class="line">	gate_desc desc;</span><br><span class="line"></span><br><span class="line">	for (; size &gt; 0; t++, size--) &#123;</span><br><span class="line">		idt_init_desc(&amp;desc, t);</span><br><span class="line">		write_idt_entry(idt, t-&gt;vector, &amp;desc);</span><br><span class="line">		if (sys)</span><br><span class="line">			set_bit(t-&gt;vector, system_vectors);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该这么多是为了保证代码整洁，原来的32和64bit定义分开，这里统一到了一起。</p>
<h2 id="9-3-ignore-irq-handler"><a href="#9-3-ignore-irq-handler" class="headerlink" title="9.3. ignore irq handler"></a>9.3. ignore irq handler</h2><p>在irq handler初始化之前，所有的对应的idt entry都会被设置成 head_32.S中的early_ignore_irq(老版本是ignore_int)，代码基本一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* This is the default interrupt &quot;handler&quot; :-) */</span><br><span class="line">ENTRY(early_ignore_irq)</span><br><span class="line">	cld</span><br><span class="line">#ifdef CONFIG_PRINTK</span><br><span class="line">	pushl %eax</span><br><span class="line">	pushl %ecx</span><br><span class="line">	pushl %edx</span><br><span class="line">	pushl %es</span><br><span class="line">	pushl %ds</span><br><span class="line">	movl $(__KERNEL_DS),%eax</span><br><span class="line">	movl %eax,%ds</span><br><span class="line">	movl %eax,%es</span><br><span class="line">	cmpl $2,early_recursion_flag</span><br><span class="line">	je hlt_loop</span><br><span class="line">	incl early_recursion_flag</span><br><span class="line">	pushl 16(%esp)</span><br><span class="line">	pushl 24(%esp)</span><br><span class="line">	pushl 32(%esp)</span><br><span class="line">	pushl 40(%esp)</span><br><span class="line">	pushl $int_msg</span><br><span class="line">	call printk</span><br><span class="line"></span><br><span class="line">	call dump_stack</span><br><span class="line"></span><br><span class="line">	addl $(5*4),%esp</span><br><span class="line">	popl %ds</span><br><span class="line">	popl %es</span><br><span class="line">	popl %edx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %eax</span><br><span class="line">#endif</span><br><span class="line">	iret</span><br></pre></td></tr></table></figure>
<h2 id="9-4-Typical-Exception-Handler-Process"><a href="#9-4-Typical-Exception-Handler-Process" class="headerlink" title="9.4 Typical Exception Handler Process"></a>9.4 Typical Exception Handler Process</h2><p>基本的exception处理流程包括如下几步：</p>
<ul>
<li>保存error code，jmp到通用的exception handler流程<ul>
<li>legacy mode: error_code</li>
<li>latest(5.4): common_exception</li>
</ul>
</li>
<li>通用的exception handler流程会首先保存context</li>
<li>调用对应的c代码的handler(地址保存在%edi中)</li>
<li>调用ret_from_exception开始返回</li>
<li>调用restore_all_kernel</li>
<li>检查是否有中断</li>
<li>恢复stack frame随后iret</li>
</ul>
<p>更加完整的流程描述如下：</p>
<ol>
<li>Saves the registers that might be used by the high-level C function on the stack.</li>
<li>Issues a cld instruction to clear the direction flag DF of eflags, thus making sure<br>that autoincreases on the edi and esi registers will be used with string<br>instructions.*</li>
<li>Copies the hardware error code saved in the stack at location esp+36 in edx.<br>Stores the value –1 in the same stack location. As we’ll see in the section “Reexecution of System Calls” in Chapter 11, this value is used to separate 0x80 exceptions from other exceptions.</li>
<li>Loads edi with the address of the high-level do_handler_name( ) C function<br>saved in the stack at location esp+32; writes the contents of es in that stack<br>location.</li>
<li>Loads in the eax register the current top location of the Kernel Mode stack. This<br>address identifies the memory cell containing the last register value saved in<br>step 1.</li>
<li>Loads the user data Segment Selector into the ds and es registers.</li>
<li>Invokes the high-level C function whose address is now stored in edi.</li>
</ol>
<p>以下，举处除零的handler为例。</p>
<h3 id="9-4-1-Legacy-do-divide-error实现"><a href="#9-4-1-Legacy-do-divide-error实现" class="headerlink" title="9.4.1. Legacy do_divide_error实现"></a>9.4.1. Legacy do_divide_error实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(divide_error)</span><br><span class="line">	RING0_INT_FRAME</span><br><span class="line">	ASM_CLAC</span><br><span class="line">	pushl_cfi $0			# no error code</span><br><span class="line">	pushl_cfi $do_divide_error</span><br><span class="line">	jmp error_code</span><br><span class="line">	CFI_ENDPROC</span><br><span class="line">END(divide_error)</span><br></pre></td></tr></table></figure>
<p>error_code是共享的处理流程，其中会调用到do_divide_error函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error_code:</span><br><span class="line">    ... # push registers</span><br><span class="line"></span><br><span class="line">	cld</span><br><span class="line">	</span><br><span class="line">	... # build up do_divide_error function stack</span><br><span class="line">	 </span><br><span class="line">	call *%edi # call do_divide_error function</span><br><span class="line">	jmp ret_from_exception</span><br><span class="line">	CFI_ENDPROC</span><br><span class="line">END(page_fault)</span><br></pre></td></tr></table></figure>
<p>do_divide_error是个c程序，定义在traps.c中的宏DO_ERROR_INFO，最终会调用do_trap来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr)		\</span></span><br><span class="line">dotraplinkage <span class="keyword">void</span> do_#<span class="meta">#name(struct pt_regs *regs, long error_code)	\</span></span><br><span class="line">&#123;									\</span><br><span class="line">	...</span><br><span class="line">	conditional_sti(regs);						\</span><br><span class="line">	do_trap(trapnr, signr, str, regs, error_code, &amp;info);		\</span><br><span class="line">	exception_exit(prev_state);					\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do_trap</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __kprobes</span><br><span class="line">do_trap(<span class="keyword">int</span> trapnr, <span class="keyword">int</span> signr, <span class="keyword">char</span> *str, struct pt_regs *regs,</span><br><span class="line">	<span class="keyword">long</span> error_code, <span class="keyword">siginfo_t</span> *info)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info)</span><br><span class="line">		force_sig_info(signr, info, tsk);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		force_sig(signr, tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步是想当前程序发送一个SIGFPE signal。ret_from_exception和5.4版本中功能类似，后面一起讲。</p>
<h3 id="9-4-2-Linux-5-4-kernel实现："><a href="#9-4-2-Linux-5-4-kernel实现：" class="headerlink" title="9.4.2. Linux 5.4 kernel实现："></a>9.4.2. Linux 5.4 kernel实现：</h3><h4 id="9-4-2-1-32bit-divide-error"><a href="#9-4-2-1-32bit-divide-error" class="headerlink" title="9.4.2.1. 32bit divide_error"></a>9.4.2.1. 32bit divide_error</h4><p>代码在entry_32.S中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(divide_error)</span><br><span class="line">	ASM_CLAC</span><br><span class="line">	pushl	$0				# 这里保存error code，0代表没有</span><br><span class="line">	pushl	$do_divide_error  # 这里保存目标c程序地址</span><br><span class="line">	jmp	common_exception</span><br><span class="line">END(divide_error)</span><br></pre></td></tr></table></figure>
<p>common_exception是通用的exception处理流程（除了double fault）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">common_exception:</span><br><span class="line">	/* the function address is in %gs&apos;s slot on the stack */</span><br><span class="line">	SAVE_ALL switch_stacks=1 skip_gs=1</span><br><span class="line">	ENCODE_FRAME_POINTER</span><br><span class="line">	UNWIND_ESPFIX_STACK</span><br><span class="line"></span><br><span class="line">	/* fixup %gs */</span><br><span class="line">	GS_TO_REG %ecx</span><br><span class="line">	movl	PT_GS(%esp), %edi		# get the function address</span><br><span class="line">	REG_TO_PTGS %ecx</span><br><span class="line">	SET_KERNEL_GS %ecx</span><br><span class="line"></span><br><span class="line">	/* fixup orig %eax */</span><br><span class="line">	movl	PT_ORIG_EAX(%esp), %edx		# get the error code</span><br><span class="line">	movl	$-1, PT_ORIG_EAX(%esp)		# no syscall to restart</span><br><span class="line"></span><br><span class="line">	TRACE_IRQS_OFF</span><br><span class="line">	movl	%esp, %eax			# pt_regs pointer</span><br><span class="line">	CALL_NOSPEC %edi          # 跳转到对应的c历程</span><br><span class="line">	jmp	ret_from_exception</span><br><span class="line">END(common_exception)</span><br></pre></td></tr></table></figure>
<p>除去一堆保存环境和测试的，这里要关注的就是跳转到c handler的代码。</p>
<h4 id="9-4-2-2-64bit-divide-error实现"><a href="#9-4-2-2-64bit-divide-error实现" class="headerlink" title="9.4.2.2. 64bit divide_error实现"></a>9.4.2.2. 64bit divide_error实现</h4><p>代码在entry_64.S中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idtentry divide_error			do_divide_error			has_error_code=0</span><br><span class="line"></span><br><span class="line">// idtentry - Generate an IDT entry stub</span><br></pre></td></tr></table></figure>
<p>idtentry: generates an IDT stub that sets up a usable kernel context, creates struct pt_regs, and calls @do_sym. </p>
<h4 id="9-4-2-2-c-handler"><a href="#9-4-2-2-c-handler" class="headerlink" title="9.4.2.2 c handler"></a>9.4.2.2 c handler</h4><p>do_divide_error实现在arch\x86\kernel\traps.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP ((void __user *)uprobe_get_trap_addr(regs))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DO_ERROR(trapnr, signr, sicode, addr, str, name)		   \</span></span><br><span class="line">dotraplinkage <span class="keyword">void</span> do_#<span class="meta">#name(struct pt_regs *regs, long error_code)	   \</span></span><br><span class="line">&#123;									   \</span><br><span class="line">	do_error_trap(regs, error_code, str, trapnr, signr, sicode, addr); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DO_ERROR(X86_TRAP_DE,     SIGFPE,  FPE_INTDIV,   IP, <span class="string">"divide error"</span>,        divide_error)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_error_trap</span><span class="params">(struct pt_regs *regs, <span class="keyword">long</span> error_code, <span class="keyword">char</span> *str,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">long</span> trapnr, <span class="keyword">int</span> signr, <span class="keyword">int</span> sicode, <span class="keyword">void</span> __user *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCU_LOCKDEP_WARN(!rcu_is_watching(), <span class="string">"entry code didn't wake RCU"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * WARN*()s end up here; fix them up before we call the</span></span><br><span class="line"><span class="comment">	 * notifier chain.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!user_mode(regs) &amp;&amp; fixup_bug(regs, trapnr))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) !=</span><br><span class="line">			NOTIFY_STOP) &#123;</span><br><span class="line">		cond_local_irq_enable(regs);</span><br><span class="line">		do_trap(trapnr, signr, str, regs, error_code, sicode, addr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，这里也会调用的通用do_trap实现中去。</p>
<h2 id="9-5-返回"><a href="#9-5-返回" class="headerlink" title="9.5. 返回"></a>9.5. 返回</h2><p>完成调用以后，ret_from_exception负责返回到原来进程中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ret_from_exception</span><br><span class="line">  - restore_all_kernel</span><br><span class="line">    - .Lno_preempt</span><br><span class="line">      - .Lirq_return</span><br><span class="line">        - IRET_FRAME -&gt; 回复堆栈</span><br><span class="line">        - INTERRUPT_RETURN -&gt; iret 或者 jmp native_iret</span><br></pre></td></tr></table></figure>
<h1 id="10-中断-Interrupt"><a href="#10-中断-Interrupt" class="headerlink" title="10. 中断(Interrupt)"></a>10. 中断(Interrupt)</h1><ul>
<li>异常最终的操作基本都是发signal给当前的进程，这是因为异常的发生往往是in time的。</li>
<li>但是对于中断，中断的trigger往往是异步的，触发时候目标进程可能在sleep状态，也就是说当前进程不是中断的目标进程。</li>
</ul>
<p>中断细节可以分成如下几类：</p>
<ul>
<li>I/O interrupts</li>
<li>Timer interrupts<ul>
<li>local APIC timer or an external timer</li>
</ul>
</li>
<li>Interprocessor interrupts</li>
</ul>
<h2 id="10-1-I-O-interrupts"><a href="#10-1-I-O-interrupts" class="headerlink" title="10.1. I/O interrupts"></a>10.1. I/O interrupts</h2><p>多台设备可能绑在同一个I/O interrupt上，使用同一条IRQ line。此时，需要一种分享的方式，一般有两种方式：</p>
<ul>
<li>IRQ sharing: 多个设备使用同一个interrupt service routines (ISRs)，这个routine需要去判断到底哪一个设备发送了中断。</li>
<li>IRQ dynamic allocation: 一次只让一个设备使用，只有激活状态的设备可以尝试独占IRQ line。</li>
</ul>
<p>另一方面，对于中断处理程序，因为其会屏蔽中断，并且可能被switch出去，所以linux会把中断处理后可能的操作分成三类：</p>
<ul>
<li>Critical</li>
<li>Noncritical</li>
<li>Noncritical deferrable</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Micro/" rel="tag"># Micro</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Interrupt/" rel="tag"># Interrupt</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/11/21/wild-pig-chapter3/" rel="prev" title="野猪书第三章读书笔记">
      <i class="fa fa-chevron-left"></i> 野猪书第三章读书笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/07/wild-pig-chapter-4-5-6/" rel="next" title="野猪书第四，五，六章读书笔记">
      野猪书第四，五，六章读书笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-中断设计constrains"><span class="nav-text">1. 中断设计constrains</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-中断和异常"><span class="nav-text">2. 中断和异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-IRQs-and-Interrupts"><span class="nav-text">3. IRQs and Interrupts</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-APIC-Advanced-Programmable-Interrupt-Controller"><span class="nav-text">4. APIC (Advanced Programmable Interrupt Controller)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Required-Exceptions"><span class="nav-text">5. Required Exceptions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-IDT"><span class="nav-text">6. IDT</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Interrupt-Trigger-Process"><span class="nav-text">7. Interrupt Trigger Process</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Interrupt-Gate"><span class="nav-text">8. Interrupt Gate</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-IDT初始化"><span class="nav-text">9. IDT初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-legacy-mode"><span class="nav-text">9.1. legacy mode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-kernel-version-5-4"><span class="nav-text">9.2. kernel version 5.4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-ignore-irq-handler"><span class="nav-text">9.3. ignore irq handler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-Typical-Exception-Handler-Process"><span class="nav-text">9.4 Typical Exception Handler Process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-1-Legacy-do-divide-error实现"><span class="nav-text">9.4.1. Legacy do_divide_error实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-2-Linux-5-4-kernel实现："><span class="nav-text">9.4.2. Linux 5.4 kernel实现：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-2-1-32bit-divide-error"><span class="nav-text">9.4.2.1. 32bit divide_error</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-2-2-64bit-divide-error实现"><span class="nav-text">9.4.2.2. 64bit divide_error实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-2-2-c-handler"><span class="nav-text">9.4.2.2 c handler</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-返回"><span class="nav-text">9.5. 返回</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-中断-Interrupt"><span class="nav-text">10. 中断(Interrupt)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-I-O-interrupts"><span class="nav-text">10.1. I/O interrupts</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leo Zhou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo Zhou</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="梅子黄时雨">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="梅子黄时雨">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>梅子黄时雨</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">梅子黄时雨</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/Linux-Thead-Model-and-Impl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/12/Linux-Thead-Model-and-Impl/" class="post-title-link" itemprop="url">Linux Thead Model and Impl</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-12 23:00:24 / Modified: 23:00:44" itemprop="dateCreated datePublished" datetime="2020-01-12T23:00:24+08:00">2020-01-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://landley.net/kdocs/ols/2002/ols2002-pages-330-337.pdf" target="_blank" rel="noopener">POSIX Threads and the Linux Kernel</a></li>
<li><a href="http://www.cs.unc.edu/~porter/courses/cse506/f12/slides/nptl.pdf" target="_blank" rel="noopener">Native POSIX Thread Library (NPTL): CSE 506 Don Porter </a></li>
<li><a href="https://yq.aliyun.com/articles/6043" target="_blank" rel="noopener">linux futex浅析</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-thread/index.html" target="_blank" rel="noopener">Linux Kernel 2.4 线程实现机制分析</a></li>
<li><a href="https://eli.thegreenplace.net/2018/basics-of-futexes/" target="_blank" rel="noopener">Basics of Futexes</a></li>
<li><a href="https://lwn.net/Articles/360699/" target="_blank" rel="noopener">A futex overview and update</a></li>
<li><a href="https://filippo.io/linux-syscall-table/" target="_blank" rel="noopener">Searchable Linux Syscall Table for x86 and x86_64</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/index.html" target="_blank" rel="noopener">Linux 内核的同步机制，第 1 部分</a></li>
</ul>
<h1 id="1-POSIX-Threads-Model"><a href="#1-POSIX-Threads-Model" class="headerlink" title="1. POSIX Threads Model"></a>1. POSIX Threads Model</h1><h2 id="1-1-Definitions"><a href="#1-1-Definitions" class="headerlink" title="1.1. Definitions"></a>1.1. Definitions</h2><ul>
<li>Process: 主要关注在resource上面<ul>
<li>an address space and a group of resources all dedicated to running that program.</li>
</ul>
</li>
<li>Thread: 主要是一个process包含多个threads<ul>
<li>the resources necessary to represent that single thread of execution. </li>
</ul>
</li>
</ul>
<h2 id="1-2-POSIX-Thread-Model-vs-Linux-Task-Model"><a href="#1-2-POSIX-Thread-Model-vs-Linux-Task-Model" class="headerlink" title="1.2. POSIX Thread Model vs Linux Task Model"></a>1.2. POSIX Thread Model vs Linux Task Model</h2><ul>
<li>类似黑名单，POSIX中大部分resource是一个process中所有thread shared，除了：<ul>
<li>CPU registers</li>
<li>User stack</li>
<li>Blocked signal mask</li>
</ul>
</li>
<li>而linux类似白名单，大部分resource都是thread独占的，除了：<ul>
<li>Address space</li>
<li>Signal handlers</li>
<li>Open files</li>
<li>Working directory</li>
</ul>
</li>
</ul>
<p>在这种情况下，POSIX的thread模型和linux的thread模型会有互相不兼容的问题，最明显的一个就是关于PID，PPID，credentials (user ID, group ID, etc), and pending signal mask.</p>
<p>换句话说，POSIX中一个process的所有thread是共享一个pid的，但是在linux中，这些所有的thread都有自己独立的pid。</p>
<p>这又进一步的带来了另外的问题，POSIX关于某个pid的操作是对于整个process而言的。无论是signal, exit, suspend/resume或者shared memory(address)的detach，在POSIX中都是对于一个process中的所有thread的集体操作。</p>
<p>但是在linux中，这些操作都是对于单个thread的操作，和整体process关系不直接关联。</p>
<h2 id="1-3-User-Space-amp-Kernel-Space-Thread-Mapping"><a href="#1-3-User-Space-amp-Kernel-Space-Thread-Mapping" class="headerlink" title="1.3. User Space &amp; Kernel Space Thread Mapping"></a>1.3. User Space &amp; Kernel Space Thread Mapping</h2><ul>
<li>M:1, 问题在于只有一个kernel thread，一旦被阻塞就整体玩完</li>
<li>1:1, 最容易实现，性能有牺牲，特别是context switch</li>
<li>M:N，多线程情况下性能能够达到最优，但是实现复杂</li>
</ul>
<h1 id="2-LinuxThreads"><a href="#2-LinuxThreads" class="headerlink" title="2. LinuxThreads"></a>2. LinuxThreads</h1><p>LinuxThreads模型使用1:1的模型，但是和POSIX lib的不兼容，因此一个能在POSIX规范中能够运行的binary，不一定能在LinuxThreads lib中正常运行。</p>
<p>LinuxThreads另外一个特点是有一个Manager Thread。</p>
<h2 id="2-1-Managed-Thread"><a href="#2-1-Managed-Thread" class="headerlink" title="2.1. Managed Thread"></a>2.1. Managed Thread</h2><p>除了线程调度(1:1模型直接有kernel完成)，其他诸如线程取消、线程间的同步等工作，都是在核外(User Space)线程库中完成的，由Manager Thread负责。</p>
<p>Manager Thread使用pipe管道来和其他线程进行通讯。管理线程的栈和用户线程的栈是分离的，管理线程在进程堆中通过malloc()分配一个THREAD_MANAGER_STACK_SIZE字节的区域作为自己的运行栈。</p>
<p>管理线程容易成为瓶颈，这是这种结构的通病；同时，管理线程又负责用户线程的清理工作，因此，尽管管理线程已经屏蔽了大部分的信号，但一旦管理线程死亡，用户线程就不得不手工清理了，而且用户线程并不知道管理线程的状态，之后的线程创建等请求将无人处理。</p>
<h2 id="2-2-therad-id和process-id"><a href="#2-2-therad-id和process-id" class="headerlink" title="2.2. therad id和process id"></a>2.2. therad id和process id</h2><p>每个LinuxThreads线程都同时具有线程id和进程id，其中进程id就是内核所维护的进程号，而线程id则由LinuxThreads分配和维护。值得注意的是每一个thread都有自己的tid(unique in process)和pid(unique in whole os)</p>
<p>因此LinuxThreads的clone函数，对于CLONE_PID没有符合POSIX要求。另外，线程的数量被限制在1024，另外还会收到全局process可用数目的限制，因为这个thread其实就是一个process。</p>
<h2 id="2-3-signal-amp-同步"><a href="#2-3-signal-amp-同步" class="headerlink" title="2.3. signal &amp; 同步"></a>2.3. signal &amp; 同步</h2><p>LinuxThread中的同步依赖于信号，当接受到一个kill signal之后，manager thread会将其转发给所有其他的thread。同时因为没有线程组的概念，因此其他signal的发送都是对于单一thread的操作。</p>
<p>LinuxThreads将使用SIGUSR1和SIGUSR2作为内部使用的restart和cancel信号，这样应用程序就不能使用这两个原本为用户保留的信号了。</p>
<h2 id="2-4-其他问题"><a href="#2-4-其他问题" class="headerlink" title="2.4. 其他问题"></a>2.4. 其他问题</h2><p>还有一些其他和POSIX线程有关的调用LinuxThreads，比如nice、setuid、setrlimit等，都是不兼容POSIX的，只针对一个thread有效果。</p>
<h1 id="3-NPTL"><a href="#3-NPTL" class="headerlink" title="3. NPTL"></a>3. NPTL</h1><p>2.6版本以后，linux kernel引入了和POSIX兼容的NPTL(Native POSIX Thread Library)多线程库。NPTL也是1:1的user和kernel space thread mapping。</p>
<h2 id="3-1-futex-Fast-userspace-mutex"><a href="#3-1-futex-Fast-userspace-mutex" class="headerlink" title="3.1. futex (Fast userspace mutex)"></a>3.1. futex (Fast userspace mutex)</h2><p>NPTL同时引入了futex，提供了一种用户thread的同步方式，具体包括了如下的特点：</p>
<ul>
<li>首先尝试在user space使用atomic的方法来快速加锁。在大部分时间，类似java的light lock，能够快速的加锁。</li>
<li>如果加锁失败，那么thread可以尝试：<ul>
<li>在原地spinning，等待lock free</li>
<li>调用syscal futex来加锁，这时候需要陷入linux kernel；futex加锁依是针对address的。</li>
</ul>
</li>
</ul>
<p>另外futex可以用来semaphores和mutex。</p>
<p>更加详细的syscall的列表可以在<code>/include/uapi/asm-generic/unistd.h</code>中找到。</p>
<h2 id="3-2-pid-amp-tgid"><a href="#3-2-pid-amp-tgid" class="headerlink" title="3.2. pid &amp; tgid"></a>3.2. pid &amp; tgid</h2><p>首先需要注意的是，两个不同的操作的结果：</p>
<ul>
<li>fork : 产生一个新的process</li>
<li>pthread_create : 产生一个新的thread</li>
</ul>
<p>但实际上fork和pthread_create都会调用到do_fork，因此所有的process都会有pid，tgid和ppid。</p>
<p>另外需要注意的是，即使在NPTL情况下，每一个thread实际还是lwp(light weight process)。</p>
<ul>
<li>pid: process(thread)的id，每一个thread/process都不一样，全局唯一</li>
<li>ppid: 创建process(thread)的parent process的pid</li>
<li>tgid(thread group id): 所有在同一个线程组中共享的id，对于线程组leader而言有pid = tgid</li>
</ul>
<p>NPTL为了兼容POSIX的操作，getpid或者对于process的操作会返回tgid或者对于所有包含相同tgid的process的操作。<br>因此，其实linux kernel内部会有两套对于process/thread操作：一套是对于tgid，一套是真实对于单个thread的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/05/UTLK-Chapter-2-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/UTLK-Chapter-2-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">UTLK Chapter 2 读书笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-05 15:54:45 / Modified: 15:55:47" itemprop="dateCreated datePublished" datetime="2020-01-05T15:54:45+08:00">2020-01-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-Address"><a href="#0-Address" class="headerlink" title="0. Address"></a>0. Address</h1><ul>
<li>Logical Address -&gt; 段式<ul>
<li>16bit Segment Selector</li>
<li>32bit Offset</li>
</ul>
</li>
<li>Linear Address (Vitual Address) -&gt; 页式</li>
<li>Physical Address</li>
</ul>
<h1 id="1-分段"><a href="#1-分段" class="headerlink" title="1. 分段"></a>1. 分段</h1><p>一个段的描述会被分成两块：</p>
<ul>
<li>Segment Selector: 类似reference id，16bit长度，用于描述<ul>
<li>一个Segment的index</li>
<li>TI(Table Indicator): 描述Segment是在GDT还是LDT</li>
<li>RPL(Requestor Privilege Level)</li>
</ul>
</li>
<li>Segment Descriptor: 描述Segment本身的信息，64bit，会有不同的类型：<ul>
<li>Code Segment Descriptor</li>
<li>Data Segment Descriptor</li>
<li>Task State Segment Descriptor (TSSD)</li>
<li>Local Descriptor Table Descriptor (LDTD)</li>
</ul>
</li>
</ul>
<p>为了加速代码执行，x86本身会提供额外的寄存器来保存Segment Selector：cs,ss,ds。</p>
<h1 id="2-Segment-in-Linux"><a href="#2-Segment-in-Linux" class="headerlink" title="2. Segment in Linux"></a>2. Segment in Linux</h1><h2 id="2-1-GDT"><a href="#2-1-GDT" class="headerlink" title="2.1. GDT"></a>2.1. GDT</h2><p>每一个CPU core都会有自己的GDT，并且大部分情况下，都是一样的内容。Linux kernel使用的GDT长度为32 slots。</p>
<h3 id="2-1-1-version-linux-2-6-13"><a href="#2-1-1-version-linux-2-6-13" class="headerlink" title="2.1.1. version linux 2.6.13"></a>2.1.1. version linux 2.6.13</h3><p>linux 2.6.13中(UTLK中的版本)，x86的GDT定义很直接(arch/i386/kernel/head.S)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The boot_gdt_table must mirror the equivalent in setup.S and is</span><br><span class="line"> * used only for booting.</span><br><span class="line"> */</span><br><span class="line">	.align L1_CACHE_BYTES</span><br><span class="line">ENTRY(boot_gdt_table)</span><br><span class="line">	.fill GDT_ENTRY_BOOT_CS,8,0</span><br><span class="line">	.quad 0x00cf9a000000ffff	/* kernel 4GB code at 0x00000000 */</span><br><span class="line">	.quad 0x00cf92000000ffff	/* kernel 4GB data at 0x00000000 */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The Global Descriptor Table contains 28 quadwords, per-CPU.</span><br><span class="line"> */</span><br><span class="line">	.align PAGE_SIZE_asm</span><br><span class="line">ENTRY(cpu_gdt_table)</span><br><span class="line">	.quad 0x0000000000000000	/* NULL descriptor */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x0b reserved */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x13 reserved */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x1b reserved */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x20 unused */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x28 unused */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x33 TLS entry 1 */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x3b TLS entry 2 */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x43 TLS entry 3 */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x4b reserved */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x53 reserved */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x5b reserved */</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到这里有两个gdt，一个是用于boot时候的<code>boot_gdt_table</code>；一个用于平时使用<code>cpu_gdt_table</code>。而这里的32个slot可以直接通过数得到。（笑）</p>
<h3 id="2-1-2-Late-Version"><a href="#2-1-2-Late-Version" class="headerlink" title="2.1.2. Late Version"></a>2.1.2. Late Version</h3><p>在2.6.13之后的版本(至少在2.6.39及之后)，GDT的定义被转移到了<code>arch/x86/kernel/cpu/common.c</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = &#123; .gdt = &#123;</span><br><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line">	[GDT_ENTRY_KERNEL32_CS]		= GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),</span><br><span class="line">	[GDT_ENTRY_KERNEL_CS]		= GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),</span><br><span class="line">	[GDT_ENTRY_KERNEL_DS]		= GDT_ENTRY_INIT(0xc093, 0, 0xfffff),</span><br><span class="line">	[GDT_ENTRY_DEFAULT_USER32_CS]	= GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff),</span><br><span class="line">	[GDT_ENTRY_DEFAULT_USER_DS]	= GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff),</span><br><span class="line">	[GDT_ENTRY_DEFAULT_USER_CS]	= GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff),</span><br><span class="line">#else</span><br><span class="line">	[GDT_ENTRY_KERNEL_CS]		= GDT_ENTRY_INIT(0xc09a, 0, 0xfffff),</span><br><span class="line">	[GDT_ENTRY_KERNEL_DS]		= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),</span><br><span class="line">	[GDT_ENTRY_DEFAULT_USER_CS]	= GDT_ENTRY_INIT(0xc0fa, 0, 0xfffff),</span><br><span class="line">	[GDT_ENTRY_DEFAULT_USER_DS]	= GDT_ENTRY_INIT(0xc0f2, 0, 0xfffff),</span><br></pre></td></tr></table></figure>
<p>其中的定义4.13之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define GDT_ENTRY_INIT(flags, base, limit) &#123; &#123; &#123; \</span><br><span class="line">		.a = ((limit) &amp; 0xffff) | (((base) &amp; 0xffff) &lt;&lt; 16), \</span><br><span class="line">		.b = (((base) &amp; 0xff0000) &gt;&gt; 16) | (((flags) &amp; 0xf0ff) &lt;&lt; 8) | \</span><br><span class="line">			((limit) &amp; 0xf0000) | ((base) &amp; 0xff000000), \</span><br><span class="line">	&#125; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>4.13之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define GDT_ENTRY_INIT(flags, base, limit)			\</span><br><span class="line">	&#123;							\</span><br><span class="line">		.limit0		= (u16) (limit),		\</span><br><span class="line">		.limit1		= ((limit) &gt;&gt; 16) &amp; 0x0F,	\</span><br><span class="line">		.base0		= (u16) (base),			\</span><br><span class="line">		.base1		= ((base) &gt;&gt; 16) &amp; 0xFF,	\</span><br><span class="line">		.base2		= ((base) &gt;&gt; 24) &amp; 0xFF,	\</span><br><span class="line">		.type		= (flags &amp; 0x0f),		\</span><br><span class="line">		.s		= (flags &gt;&gt; 4) &amp; 0x01,		\</span><br><span class="line">		.dpl		= (flags &gt;&gt; 5) &amp; 0x03,		\</span><br><span class="line">		.p		= (flags &gt;&gt; 7) &amp; 0x01,		\</span><br><span class="line">		.avl		= (flags &gt;&gt; 12) &amp; 0x01,		\</span><br><span class="line">		.l		= (flags &gt;&gt; 13) &amp; 0x01,		\</span><br><span class="line">		.d		= (flags &gt;&gt; 14) &amp; 0x01,		\</span><br><span class="line">		.g		= (flags &gt;&gt; 15) &amp; 0x01,		\</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中32 slots定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_page</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">gdt</span>[<span class="title">GDT_ENTRIES</span>];</span></span><br><span class="line">&#125; __attribute__((aligned(PAGE_SIZE)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Number of entries in the GDT table:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRIES			16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_SIZE			(GDT_ENTRIES*8)</span></span><br></pre></td></tr></table></figure>
<p>同时可以看到每一个slot的长度是64bit，8bytes。</p>
<h2 id="2-2-LDT"><a href="#2-2-LDT" class="headerlink" title="2.2. LDT"></a>2.2. LDT</h2><p>LDT在默认情况下，每一个core也只有一个，对应的descriptor分配在gdt固定的位置上。slots个数为8192，单个slot长度为8 bytes，这些定义在2.6.13后的linux版本中保持一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Maximum number of LDT entries supported. */</span><br><span class="line">#define LDT_ENTRIES	8192</span><br><span class="line">/* The size of each LDT entry. */</span><br><span class="line">#define LDT_ENTRY_SIZE	8</span><br></pre></td></tr></table></figure>
<h2 id="2-3-Kernel-amp-User-Segment"><a href="#2-3-Kernel-amp-User-Segment" class="headerlink" title="2.3. Kernel &amp; User Segment"></a>2.3. Kernel &amp; User Segment</h2><p>对于指令和数据段，Linux只是简单的使用了x86的段结构，包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// --------- sgement.h</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Segment selector values corresponding to the above entries:</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define __KERNEL_CS			(GDT_ENTRY_KERNEL_CS*8)</span><br><span class="line">#define __KERNEL_DS			(GDT_ENTRY_KERNEL_DS*8)</span><br><span class="line">#define __USER_DS			(GDT_ENTRY_DEFAULT_USER_DS*8 + 3)</span><br><span class="line">#define __USER_CS			(GDT_ENTRY_DEFAULT_USER_CS*8 + 3)</span><br><span class="line">#define __ESPFIX_SS			(GDT_ENTRY_ESPFIX_SS*8)</span><br></pre></td></tr></table></figure>
<p>其中后续的都是gdt的index：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define GDT_ENTRY_KERNEL_CS		12</span><br><span class="line">#define GDT_ENTRY_KERNEL_DS		13</span><br><span class="line">#define GDT_ENTRY_DEFAULT_USER_CS	14</span><br><span class="line">#define GDT_ENTRY_DEFAULT_USER_DS	15</span><br><span class="line">...</span><br><span class="line">#define GDT_ENTRY_ESPFIX_SS		26</span><br></pre></td></tr></table></figure>
<h1 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a>2. 分页</h1><p>64bit的x86_64的page size依然是4KB，但是包含4级页表：</p>
<ul>
<li>address size bits: 48</li>
<li>linear address split: 9 + 9 + 9 + 9 + 12</li>
</ul>
<p>Linux的页表包括多层，最多4层：</p>
<ul>
<li>Page Global Directory -&gt; PGDIR_SHIFT</li>
<li>Page Upper Directory -&gt; PUD_SHIFT = 30</li>
<li>Page Middle Directory -&gt; PMD_SHIFT = 21</li>
<li>Page Table -&gt;  PAGE_SHIFT = 12</li>
</ul>
<p>其实x86最多支持5层：<a href="https://software.intel.com/sites/default/files/managed/2b/80/5-level_paging_white_paper.pdf" target="_blank" rel="noopener">5-Level Paging and 5-Level EPT</a>。因此额外加入了一个P4D_SHIFT(Page 4th Directory)。linux因此也加入了新的patch: <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Intel-5-Level-Paging" target="_blank" rel="noopener">Intel Working On 5-Level Paging To Increase Linux Virtual/Physical Address Space</a></p>
<h2 id="2-1-x86分页"><a href="#2-1-x86分页" class="headerlink" title="2.1. x86分页"></a>2.1. x86分页</h2><p>x86代码中支持2，3，4层分页，分别在不同的文件中定义：</p>
<ul>
<li>arch/x86/include/asm/pgtable-2level_types.h</li>
<li>arch/x86/include/asm/pgtable-3level_types.h</li>
<li>arch/x86/include/asm/pgtable_32_types.h</li>
<li>arch/x86/include/asm/pgtable_64_types.h</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifdef CONFIG_X86_5LEVEL</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * PGDIR_SHIFT determines what a top-level page table entry can map</span><br><span class="line"> */</span><br><span class="line">#define PGDIR_SHIFT	pgdir_shift</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 4th level page in 5-level paging case</span><br><span class="line"> */</span><br><span class="line">#define P4D_SHIFT		39</span><br><span class="line"></span><br><span class="line">#define MAX_POSSIBLE_PHYSMEM_BITS	52</span><br><span class="line"></span><br><span class="line">#else /* CONFIG_X86_5LEVEL */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * PGDIR_SHIFT determines what a top-level page table entry can map</span><br><span class="line"> */</span><br><span class="line">#define pgdir_shift		39</span><br><span class="line"></span><br><span class="line">#endif /* CONFIG_X86_5LEVEL */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 3rd level page</span><br><span class="line"> */</span><br><span class="line">#define PUD_SHIFT	30</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * PMD_SHIFT determines the size of the area a middle-level</span><br><span class="line"> * page table can map</span><br><span class="line"> */</span><br><span class="line">#define PMD_SHIFT	21</span><br><span class="line"></span><br><span class="line">/* PAGE_SHIFT determines the page size */</span><br><span class="line">#define PAGE_SHIFT		12</span><br></pre></td></tr></table></figure>
<p>注意这里的长度是page table的一个entry所指向的地址长度，而不是总的长度，所以这里也就看不到PTE表的SHIFT定义了。</p>
<h2 id="2-2-ARM"><a href="#2-2-ARM" class="headerlink" title="2.2. ARM"></a>2.2. ARM</h2><p>ARM本身支持多种page size，linux使用了4KB，两级/三级页表：</p>
<ul>
<li>PGDIR_SHIFT -&gt; 21, 30</li>
<li>PMD_SHIFT -&gt; 21, 21</li>
<li>PAGE_SIZE -&gt; 12, 12</li>
</ul>
<p>有意思的是2级页表的情况下，第一级页表有2048 entry(2^11)，每个entry 8bytes，包括两个指针，每一个都指向一个二级页表；不过这两个页表在内存上市连续的(每一个叫一个section)，每一个都有256个entry，合起来就有2^9 = 512 entry。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define PTRS_PER_PTE		512</span><br><span class="line">#define PTRS_PER_PMD		1</span><br><span class="line">#define PTRS_PER_PGD		2048</span><br><span class="line"></span><br><span class="line">#define SECTION_SHIFT		20</span><br><span class="line">#define SECTION_SIZE		(1UL &lt;&lt; SECTION_SHIFT)</span><br><span class="line">#define SECTION_MASK		(~(SECTION_SIZE-1))</span><br></pre></td></tr></table></figure>
<p>ARM的三层页表是来支持huge page的。</p>
<h2 id="2-3-ARM64"><a href="#2-3-ARM64" class="headerlink" title="2.3. ARM64"></a>2.3. ARM64</h2><p>ARM64支持最多4级页表和最大64KB page size。linux选择了：</p>
<ul>
<li>3 (39bits)or 4 (48bits)级页表 + 4KB page size</li>
<li>2 (42bits)级页表 + 3 (52bits)级页表+ 64KB page size</li>
</ul>
<h2 id="2-4-RISC-V"><a href="#2-4-RISC-V" class="headerlink" title="2.4. RISC-V"></a>2.4. RISC-V</h2><p>RISC-V本身支持非常多的virtual memory page的layout，参考：</p>
<ul>
<li><a href="https://simonsungm.github.io/2019/10/20/RISC-V-Linux-Page-Table-I/" target="_blank" rel="noopener">RISC-V Linux Page Table I</a></li>
<li><a href="https://riscv.org/specifications/privileged-isa/" target="_blank" rel="noopener">Privileged ISA Specification</a></li>
</ul>
<p>linux选择了：</p>
<ul>
<li>2级(22bits)页表 + 4KB page size</li>
<li>三级页表(22bits, 30bits) + 4KB page size</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/29/SSA-Construction-and-Destruction-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/29/SSA-Construction-and-Destruction-1/" class="post-title-link" itemprop="url">SSA Construction and Destruction(1)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-12-29 15:30:22 / Modified: 15:31:08" itemprop="dateCreated datePublished" datetime="2019-12-29T15:30:22+08:00">2019-12-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-SSA-Construction"><a href="#1-SSA-Construction" class="headerlink" title="1. SSA Construction"></a>1. SSA Construction</h1><h2 id="1-1-CFG-to-SSA-Valid-Transformation"><a href="#1-1-CFG-to-SSA-Valid-Transformation" class="headerlink" title="1.1. CFG to SSA Valid Transformation"></a>1.1. CFG to SSA Valid Transformation</h2><p>Two conditions should be satisfied:</p>
<ol>
<li>Correctness of form: Each variable mentioned in the transformed program must have exactly one definition.  </li>
<li>Semantic invariance: two coressponding paths in CFG and SSA should lead to same value for each variables at end.</li>
</ol>
<h2 id="1-2-Dominance-Frontier"><a href="#1-2-Dominance-Frontier" class="headerlink" title="1.2. Dominance Frontier"></a>1.2. Dominance Frontier</h2><ul>
<li>dominate: n &gt;= m, if every path to m pass n</li>
<li>strict dominate: n &gt;= m and n != m</li>
<li>immediate dominator: n strict dominate m and n is the closet node of so -&gt; idom(m) = n</li>
</ul>
<p>Dominance Frontiers of node n are nodes m satisfy:</p>
<ul>
<li>m is not strict dominated by n</li>
<li>exist one m pre-node p which is dominated by n</li>
</ul>
<p>we define : df(n) = { m };</p>
<p>Interesting things here:</p>
<ul>
<li>m may be idom(n)</li>
<li>n may be in df(n)</li>
</ul>
<p>Consider the second case: </p>
<p>If n is in df(n), then: </p>
<ul>
<li>there should be one cycle from n to n. It also means there’s one path from root to n which pass n intermediately</li>
<li>and there must be one path from root n which does not contains n inside</li>
<li>in such case, there are at least two paths reach n, leading to requirments of phi-function</li>
</ul>
<p>Normaly you may find such n in df(n) at loop header.</p>
<h3 id="1-2-1-Calculate-Dominace-Frontier"><a href="#1-2-1-Calculate-Dominace-Frontier" class="headerlink" title="1.2.1. Calculate Dominace Frontier"></a>1.2.1. Calculate Dominace Frontier</h3><p>Simple but ineffcient way to calculate df is check every node m of n ( n &gt;= m), test all its successor if it is dominated by n.</p>
<p>However, as a matter of fact, nodes each other contains relationship. Some information may reuse. We focus on dominate information.</p>
<h4 id="1-2-1-1-Consititue-of-DF-n"><a href="#1-2-1-1-Consititue-of-DF-n" class="headerlink" title="1.2.1.1 Consititue of DF(n)"></a>1.2.1.1 Consititue of DF(n)</h4><p>First prove: If p is in df(n), then p must at least exists in </p>
<ul>
<li>one of df(m) where idom(m) = n</li>
<li>group of successor(n)</li>
</ul>
<p>suppose p is in df(n), but neither in successor(n), nor in any of df(m) where idom(m) = n</p>
<ul>
<li>n is not strict dominate p, n !&gt; p</li>
<li>one precessor m’ of p is dominate by n, n &gt;= m’</li>
<li>idom(m’) != n since p is in df(m’)</li>
</ul>
<p>in such case</p>
<ul>
<li>there must one m (idom(m) = n) dominate m’, we name one of them as m+</li>
<li>m+ must not dominate p, otherwise since n &gt; m+, leading to n &gt; p</li>
</ul>
<p>then we get p is in df(m+) which is conflict.</p>
<p>However, on the other hand, not all nodes in up 2 kinds are in df(n), we need to remove those nodes x dominated by n and prove remaining nodes are really in df(n)</p>
<p>Those nodes dominated by n should be obviously removed; For remaining nodes since it is successor node is n(n &gt;= n) or one of its successor node k &lt;= m, plusing n &gt; m, then n &gt; k. Thoese remaining nodes should be in df(n).</p>
<p>As conclusions, we named two kinds of df(n) nodes as:</p>
<ul>
<li>df_base(n) = { m succ(n) | n !&gt; m }</li>
<li>df_ind(n) = { p in df(m) | idom(m) = n, n !&gt; p} </li>
</ul>
<h4 id="1-2-1-2-Simplfy-Checking-Process"><a href="#1-2-1-2-Simplfy-Checking-Process" class="headerlink" title="1.2.1.2 Simplfy Checking Process"></a>1.2.1.2 Simplfy Checking Process</h4><p>We may use idom(p) to check if n dominates the p in up process. It helps to reduce the complexity of exclusive process.</p>
<p>We could approve, for df_base and df_ind, restriction <code>n !&gt; m</code> is equal to <code>idom(m) != n</code>. However, for df_base, <code>n !&gt; m</code> -&gt; <code>idom(m) != n</code> is obvious, since m is just successor of n.</p>
<p>Let us focus on df_ind. Given :</p>
<ul>
<li>p is in df(m) where idom(m) = n<ul>
<li>one prec(p), named sp, m &gt;= sp</li>
<li>m !&gt; p</li>
<li>m could reach p</li>
</ul>
</li>
<li>n &gt;= p</li>
</ul>
<p>In such case, if idom(p) != n, let idom(p) = x, then x !&gt; m, since idom(m) = n, otherwise, idom(m) will be x. And slo m !&gt; x, otherwise m will dominate p. So, there will be two path from n to p, one pass m and one pass x, it will be conflict with x &gt; p prerequisite.</p>
<p>Here we could get <code>n !&gt; m</code> -&gt; <code>idom(m) != n</code> is also true for base_ind. Then we could simple the df(n) as calculte:</p>
<ul>
<li>df_base(n) = { m succ(n) | idom(m) != n }</li>
<li>df_ind(n) = { p in df(m) | idom(m) = n, idom(p) != n} </li>
</ul>
<p>idom(m) is easy to calculate in one dominate tree and we could rely on one bottomup traversal of the dominator tree to build up all df(n) for each onde:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void calDF(DominateTree tree, Map&lt;DominateNode, DF&gt; output) &#123;</span><br><span class="line">    Queue&lt;DominateNode&gt; queue;</span><br><span class="line">    </span><br><span class="line">    queue.push(tree.root);</span><br><span class="line">    </span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        DominateNode n = queue.pop();</span><br><span class="line">        </span><br><span class="line">        if (!n.visited() &amp;&amp; n.hasChild()) &#123;</span><br><span class="line">            queue.pushAll(n.children());</span><br><span class="line">            n.visit();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // handle node, you can get calculated DF from output</span><br><span class="line">            calculateDF(node, output);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void calculateDF(DominateNode node, Map&lt;DominateNode, DF&gt; output) &#123;</span><br><span class="line">    DF df;</span><br><span class="line">    for (DominateNode sn : node.successors()) &#123;</span><br><span class="line">        if (sn.idom() != n) &#123;</span><br><span class="line">          df.add(sn);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (DominateNode dn : node.children()) &#123;</span><br><span class="line">        // since visit from bottom, must be calculated</span><br><span class="line">        DF cdf = output.get(dn);</span><br><span class="line">        for (DominateNode cdfn : cdf) &#123;</span><br><span class="line">            if (cdfn.idom() != n) &#123;</span><br><span class="line">                df.add(cdfn)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    output.put(node, df);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-Placement-of-phi-instructions"><a href="#1-3-Placement-of-phi-instructions" class="headerlink" title="1.3. Placement of phi-instructions"></a>1.3. Placement of phi-instructions</h2><p>Choose one conservative solution: for one variable x, we place phi-instruction for it in each node of df(n) where n contains assignment of x or it has been inserted one phi-function of x.(Since phi-function itself is also one assignment of x)</p>
<p>The whole process then is very easy, for each varialbe x:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Queue workList;</span><br><span class="line"></span><br><span class="line">// put all nodes contains assignment of x</span><br><span class="line">for (Node n : cfg.selectNodesWithAssignment(x)) &#123;</span><br><span class="line">    workList.push(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (!workList.isEmpty()) &#123;</span><br><span class="line">    Node n = workList.pop();</span><br><span class="line">    </span><br><span class="line">    // put phi-function in each node in df(n)</span><br><span class="line">    // and put these node into workList</span><br><span class="line">    for (Node dfn : n.df()) &#123;</span><br><span class="line">        if (!dfn.isVisited()) &#123;</span><br><span class="line">            dfn.insertPhi(x);</span><br><span class="line">            workList.push(dfn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-Renaming-of-Variables"><a href="#1-4-Renaming-of-Variables" class="headerlink" title="1.4. Renaming of Variables"></a>1.4. Renaming of Variables</h2><p>Here we need to take care 4 kinds of usage of one variable x:</p>
<ul>
<li>l-value(左值) in assignment</li>
<li>r-value(右值) in assignment</li>
<li>l-value(左值) in phi-function</li>
<li>r-value(右值) in phi-function</li>
</ul>
<p>We will do one BFS in the tree with one stack to record context of one variable and one counter to record current version. l-value always brings one new version of variable (counter ++) and push itself into stack to update context.</p>
<p>For r-value in assignment, just use current variable version in context; However, in phi-function we need to pick up which version shoul based on position.</p>
<p>Another problem is when should we update the phi-function r-value: we only update phi-function r-value when it is one node’s successor. In such case, we could know path index of the node.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start with markNode(root)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// we could just save parent context here</span></span><br><span class="line">    saveParentContext();</span><br><span class="line">    </span><br><span class="line">    foreach(Assignment as : node.instrs()) &#123;</span><br><span class="line">        <span class="comment">// assign version for assignment</span></span><br><span class="line">        renameWithContextAndIncCounter(as.lVariable);</span><br><span class="line">        renameWithContext(as.rVariables());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// update phi-function in succeesor node</span></span><br><span class="line">    foreach(Node sucNode: node.succs()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sucNode.containsPhi()) &#123;</span><br><span class="line">            <span class="comment">// calculate index and update related node version</span></span><br><span class="line">            updatePhiRValue(node, sucNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// call childrens</span></span><br><span class="line">    foreach(Node child: node.children()) &#123;</span><br><span class="line">        markNode(child);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// pop stack back to restore envionment to parent status</span></span><br><span class="line">    restoreParentContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-Proof-Correctness"><a href="#1-5-Proof-Correctness" class="headerlink" title="1.5. Proof Correctness"></a>1.5. Proof Correctness</h2><p>First define some notation:</p>
<ul>
<li>df(S) = union of all df(s) for all s in S</li>
<li>df+(S) = limit df(df(S’)) + df(S’), until no more change</li>
<li>join(S)={n | ∃ converging paths m -&gt; n and k -&gt; n, m,k ∈ S}</li>
<li>join+(S) limit join(join(S’)) + join(S’), until no more change</li>
</ul>
<p>Let S be nodes containing assignments of varaible x. We need to approve: for each node in join+(S), there must be one phi-function in df+(S).</p>
<p>And also, we need prove, after ‘placement of phi-function’ &amp; ‘Renmaing Variable’, the output is SSA and with following property:</p>
<ul>
<li>convential</li>
<li>minimal </li>
<li>no-pruned </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/16/Compile-LLVM-Clang-Windows/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/16/Compile-LLVM-Clang-Windows/" class="post-title-link" itemprop="url">Compile LLVM & Clang @ Windows</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-12-16 22:18:07 / Modified: 23:06:36" itemprop="dateCreated datePublished" datetime="2019-12-16T22:18:07+08:00">2019-12-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Prepare-Environment"><a href="#1-Prepare-Environment" class="headerlink" title="1. Prepare Environment"></a>1. Prepare Environment</h1><p>We need :</p>
<ul>
<li><strong>cmake</strong>: <a href="https://cmake.org/download/" target="_blank" rel="noopener">https://cmake.org/download/</a>, choose windows version</li>
<li><strong>git</strong>: <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></li>
<li><strong>Visual Studio 2019</strong>: <a href="https://visualstudio.microsoft.com/" target="_blank" rel="noopener">https://visualstudio.microsoft.com/</a>, Community Version is enough </li>
</ul>
<h1 id="2-Clone-LLVM-project"><a href="#2-Clone-LLVM-project" class="headerlink" title="2. Clone LLVM project"></a>2. Clone LLVM project</h1><p>Two ways to get LLVM project source code</p>
<ul>
<li>git clone —config core.autocrlf=false <a href="https://github.com/llvm/llvm-project.git" target="_blank" rel="noopener">https://github.com/llvm/llvm-project.git</a></li>
<li>download source code from : <a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">http://releases.llvm.org/download.html</a></li>
</ul>
<p>However, the second way needs you</p>
<ul>
<li>put clang source code into llvm/tools with folder name as <code>clang</code></li>
<li>the build script will check if the folder existed and build clang project at same time if so</li>
</ul>
<p>The first way needs to add <code>-DLLVM_ENABLE_PROJECTS</code> flags to enable related project, the project could be <code>clang, clang-tools-extra, libcxx, libcxxabi, libunwind, lldb, compiler-rt, lld, polly, or debuginfo-test</code>.</p>
<h1 id="3-Use-CMake-to-generated-sln-file"><a href="#3-Use-CMake-to-generated-sln-file" class="headerlink" title="3. Use CMake to generated .sln file"></a>3. Use CMake to generated .sln file</h1><p>use first one as example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd llvm-project</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line"></span><br><span class="line">cmake -G &lt;generator&gt; [options] ../llvm</span><br></pre></td></tr></table></figure>
<p>Based on Visual Studio version you installed, the <code>generator</code> could be:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><generator></th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Visual Studio 16 2019</strong></td>
<td>Generates Visual Studio 2019 project files. Use -A option to specify architecture.</td>
</tr>
<tr>
<td><strong>Visual Studio 15 2017 [arch]</strong></td>
<td>Generates Visual Studio 2017 project files. Optional [arch] can be “Win64” or “ARM”.</td>
</tr>
<tr>
<td><strong>Visual Studio 14 2015 [arch]</strong></td>
<td>Generates Visual Studio 2015 project files. Optional [arch] can be “Win64” or “ARM”.</td>
</tr>
<tr>
<td><strong>Visual Studio 12 2013 [arch]</strong></td>
<td>Generates Visual Studio 2013 project files. Optional [arch] can be “Win64” or “ARM”.</td>
</tr>
<tr>
<td><strong>Visual Studio 11 2012 [arch]</strong></td>
<td>Generates Visual Studio 2012 project files. Optional [arch] can be “Win64” or “ARM”.</td>
</tr>
<tr>
<td><strong>Visual Studio 10 2010 [arch]</strong></td>
<td>Generates Visual Studio 2010 project files. Optional [arch] can be “Win64” or “IA64”.</td>
</tr>
<tr>
<td><strong>Visual Studio 9 2008 [arch]</strong></td>
<td>Generates Visual Studio 2008 project files. Optional [arch] can be “Win64” or “IA64”.</td>
</tr>
</tbody>
</table>
</div>
<p>It will take some time to generate related <code>LLVM.sln</code> file in folder <code>builder</code>.</p>
<h1 id="4-Open-Project-and-Compile"><a href="#4-Open-Project-and-Compile" class="headerlink" title="4. Open Project and Compile"></a>4. Open Project and Compile</h1><p>Now you could open the <code>LLVM.sln</code>, Visual Studio will automatically load all related resources to build up the LLVM project.</p>
<p>Normally, it will take a long time (&gt;1.5h) to build up whole project in Vistual Studio. After it done its work, you could get the <code>clang</code>/<code>llc</code> binary in one debug output folder.</p>
<p>It’s a good choice to have a meal after you start the building process and check it when you’ve enjoied the dinner. :)</p>
<p>Have a wonderful time in LLVM world.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/11/Compile-LLVM-Clang-Ubuntu-18-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/11/Compile-LLVM-Clang-Ubuntu-18-04/" class="post-title-link" itemprop="url">Compile LLVM & Clang @ Ubuntu 18.04</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-12-11 21:34:54 / Modified: 22:07:53" itemprop="dateCreated datePublished" datetime="2019-12-11T21:34:54+08:00">2019-12-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Prepare-Environment"><a href="#1-Prepare-Environment" class="headerlink" title="1. Prepare Environment"></a>1. Prepare Environment</h2><p>Use <code>apt</code> to install required pakcage:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line"></span><br><span class="line">sudo apt install build-essential cmake python3-dev libncurses5-d make</span><br></pre></td></tr></table></figure>
<h2 id="2-Download-the-source-code"><a href="#2-Download-the-source-code" class="headerlink" title="2. Download the source code"></a>2. Download the source code</h2><p>You may clone it from github, containting latest code and being able to upstream:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/llvm/llvm-project.git</span><br></pre></td></tr></table></figure>
<p>However, it will contain all history and dev code, leading to long time when downloading the source code.</p>
<p>If network status is poor, better to download each latest source code for llvm and clang in <a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">LLVM Download Page</a>.</p>
<p>Take LLVM 9.0 as example:</p>
<ul>
<li><a href="http://releases.llvm.org/9.0.0/llvm-9.0.0.src.tar.xz" target="_blank" rel="noopener">LLVM Source Code</a></li>
<li><a href="http://releases.llvm.org/9.0.0/cfe-9.0.0.src.tar.xz" target="_blank" rel="noopener">Clang source code</a></li>
</ul>
<p>You will get two tar.gz:</p>
<ul>
<li>llvm-9.0.0.src.tar.xz</li>
<li>cfe-9.0.0.src.tar.xz</li>
</ul>
<p>Clang source code should put into folder <code>${LLVM_SOURCE_CODE}/tools/clang</code>(checking INSTALL.txt in clang source file).</p>
<p>the final path as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">llvm-9.0.0-src</span><br><span class="line">  ...</span><br><span class="line">  |- tools</span><br><span class="line">  ...</span><br><span class="line">     |- clang (renamed from cfe-9.0.0)</span><br></pre></td></tr></table></figure>
<h2 id="3-Build-Code"><a href="#3-Build-Code" class="headerlink" title="3. Build Code"></a>3. Build Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line"></span><br><span class="line">cmake -G &quot;Unix Makefiles&quot; ../llvm-9.0.0-src</span><br></pre></td></tr></table></figure>
<p>It will scan CMakefiles.txt, automatically involving clang project.</p>
<h2 id="4-Check-Result"><a href="#4-Check-Result" class="headerlink" title="4. Check Result"></a>4. Check Result</h2><p><code>bin</code> folder will be found in <code>build</code> folder. Setup the Path in ~/.bashrc :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;BUILD_FOLDER&#125;/bin:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure>
<p>Then <code>source ~/.bahsrc</code>. Now checking with command <code>clang</code> and <code>llc</code>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/07/wild-pig-chapter-4-5-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/07/wild-pig-chapter-4-5-6/" class="post-title-link" itemprop="url">野猪书第四，五，六章读书笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-12-07 23:03:30 / Modified: 23:05:04" itemprop="dateCreated datePublished" datetime="2019-12-07T23:03:30+08:00">2019-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四章：Overview"><a href="#第四章：Overview" class="headerlink" title="第四章：Overview"></a>第四章：Overview</h1><p>数据结构需要改动时候，一般需要更新代码或者内部数据结构，此时会碰到两个问题：</p>
<ul>
<li>滚动更新数据库相对复杂</li>
<li>依赖客户更新不可靠</li>
</ul>
<p>这种情况下，新旧数据会同时存在系统中，需要双向兼容：</p>
<ul>
<li>向后兼容：新代码可以读取旧数据</li>
<li>向前兼容：旧代码可以读取新数据</li>
</ul>
<h1 id="语言内置编码方案问题"><a href="#语言内置编码方案问题" class="headerlink" title="语言内置编码方案问题"></a>语言内置编码方案问题</h1><ul>
<li>和语言绑定的编码方案往往是语言specified</li>
<li>对象的序列化和反序列化往往需要跳过一些安全check，注入恶意代码变得有可能。比如在java默认构造函数中注入代码。</li>
<li>不同版本之间的实现往往是不兼容的，最明显的就是Java的jackson系列json序列化lib</li>
<li>性能也往往不是这些lib着重考虑的因素</li>
</ul>
<h1 id="数据流转方式"><a href="#数据流转方式" class="headerlink" title="数据流转方式"></a>数据流转方式</h1><ul>
<li>通过数据库</li>
<li>通过service call: Rest and RPC</li>
<li>通过异步message发送<ul>
<li>缓冲区更好的可靠性</li>
<li>自动重发</li>
<li>message queue隐藏发送方信息</li>
<li>多个接收方</li>
<li>解耦发送和接收方，通过message queue</li>
</ul>
</li>
</ul>
<h1 id="第五章：Overview"><a href="#第五章：Overview" class="headerlink" title="第五章：Overview"></a>第五章：Overview</h1><p>replication考虑因素</p>
<ul>
<li>single leader, multi leader and leaderless<ul>
<li>单主节点：只有一个节点负责写入</li>
<li>多主节点：多节点写入</li>
<li>无主节点：所有节点都可以写入</li>
</ul>
</li>
<li>数据一致性方式：synchronous或者asynchronous<ul>
<li>可以一个节点同步，保证已经额外有一份copy，然后其他的进行异步同步，也可以叫半同步</li>
</ul>
</li>
<li>handle failed replica</li>
<li>read-your-writes and mono‐ tonic reads guarantees.</li>
</ul>
<h1 id="CS模式"><a href="#CS模式" class="headerlink" title="CS模式"></a>CS模式</h1><h2 id="配置新节点"><a href="#配置新节点" class="headerlink" title="配置新节点"></a>配置新节点</h2><ul>
<li>一般使用snapshot的方式来配置新的节点</li>
<li>然后通过数据更新日志来更新新节点</li>
</ul>
<h2 id="处理节点失效"><a href="#处理节点失效" class="headerlink" title="处理节点失效"></a>处理节点失效</h2><ul>
<li>追赶式恢复 -&gt; 通过磁盘的日志</li>
<li>基于语句的复制 -&gt; 比如记录输入的SQL语句<ul>
<li>now()，random()等函数是非确定的</li>
<li>自递增的column不适适用</li>
<li>where等语句效果取决于数据情况</li>
<li>带副作用的操作，比如触发器，用户定义函数</li>
</ul>
</li>
<li>基于预写日志(WAL)传输<ul>
<li>日志即存储，日志结构的存储引擎（SSTables和LSM-trees）</li>
<li>覆盖型的写入(B-tree)，日志作为内存中，尚未刷入磁盘的备份</li>
</ul>
</li>
<li>基于行的逻辑日志复制<ul>
<li>一系列记录数据行级，但是更加详细和准确的描述，比如mysql的binlog</li>
</ul>
</li>
<li>基于触发器的复制 -&gt; 类似event</li>
</ul>
<h2 id="复制滞后的问题"><a href="#复制滞后的问题" class="headerlink" title="复制滞后的问题"></a>复制滞后的问题</h2><ul>
<li>读自己的写 -&gt; 也就是所谓的写后读，写完以后进行读取，此时可能读取到一个尚未得到更新数据的节点<ul>
<li>目标就是：读写一致性</li>
<li>记录节点更新时间</li>
<li>引入最后请求时间戳</li>
</ul>
</li>
<li>单调读 -&gt; 两次从不同的两个节点可能读到不同的数据<ul>
<li>始终保持在一个节点上读，除非节点失效，保证不会一次读取新的以后再另外一个节点读到旧的数据。</li>
<li>单调读一致性</li>
</ul>
</li>
<li>前缀一致读：一系列的数据读取得到的数据顺序和写入顺序保持一致<ul>
<li>不相关的数据读取顺序不需要和写入顺序一致</li>
<li>解决方法之一：相关数据由同一节点处理</li>
</ul>
</li>
</ul>
<h1 id="多主节点"><a href="#多主节点" class="headerlink" title="多主节点"></a>多主节点</h1><h2 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h2><ul>
<li>类似于hash，相同或者类同数据只在一个节点处理</li>
<li>给每一个写都带一个UUID</li>
<li>自定义冲突解决逻辑：<ul>
<li>在写入时候解决，写入时候发现冲突要求解决</li>
<li>在读取时候解决，返回多个可能结果，让用户自己选择</li>
</ul>
</li>
<li>自动冲突解决：<ul>
<li>无冲突的复制数据类型</li>
<li>可合并的持久数据结果</li>
<li>操作转换</li>
</ul>
</li>
</ul>
<h1 id="无主节点复制"><a href="#无主节点复制" class="headerlink" title="无主节点复制"></a>无主节点复制</h1><p>还是多看论文把。</p>
<h1 id="第六章：数据分区"><a href="#第六章：数据分区" class="headerlink" title="第六章：数据分区"></a>第六章：数据分区</h1><p>分区定义：每一条数据只属于某个特定的分区。</p>
<p>如何分区</p>
<ul>
<li>随机分发分区 -&gt; 代价是每次查询都需要扫描全局</li>
<li>基于关键字分区<ul>
<li>首先对关键字进行排序，分段进行分区</li>
<li>内部可以使用SSTables和LSM-Trees保存</li>
<li>不合适的关键字选择容易出现热点节点</li>
</ul>
</li>
<li>基于hash分区<ul>
<li>不支持range搜索 -&gt; 容易退化成全局搜索</li>
<li>折衷 -&gt; 复合主键<ul>
<li>一个键做hash，其他作为排序</li>
</ul>
</li>
<li>所以核心就是选择合适的key作为hash</li>
<li>一致性哈希</li>
</ul>
</li>
</ul>
<h1 id="分区和二级索引"><a href="#分区和二级索引" class="headerlink" title="分区和二级索引"></a>分区和二级索引</h1><p>二级索引索引就是非主键索引以外的索引，而主键索引一般是作为分区来作用的。</p>
<p>很多数据库不支持二级索引，比如HBase。</p>
<p>有两种主要的方法来支持二级索引的分区</p>
<ul>
<li>基于文档的分区<ul>
<li>各个分区独自保存自己的二级索引</li>
<li>实现简单，写快，但是读时候性能难讲</li>
<li>更加类似于分区local的二级索引</li>
</ul>
</li>
<li>基于词条的分区<ul>
<li>基于全局进行索引build</li>
<li>同时对这个索引构建主键进行分区操作</li>
<li>写时候性能变差，但是读的时候优势</li>
<li>更新异步的话，可以减少写性能损失</li>
</ul>
</li>
</ul>
<p>分区调整：</p>
<ul>
<li>固定数据数量</li>
<li>动态分区</li>
<li>按节点比例分区</li>
</ul>
<h1 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h1><p>三种方式client到数据节点：</p>
<ul>
<li>随机选择一个节点，如果不对，那么节点进行转发</li>
<li>中间有一层路由层，了解所有分区信息，然后进行转发</li>
<li>客户端自己有所有分区信息，直接读取节点</li>
</ul>
<h1 id="并行查询执行"><a href="#并行查询执行" class="headerlink" title="并行查询执行"></a>并行查询执行</h1><p>多个或者复杂的查询可以拆分成更加fragement的操作，分到不同的节点，提高性能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/05/Linux-Interrupt-Part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/05/Linux-Interrupt-Part-1/" class="post-title-link" itemprop="url">Linux Interrupt Part 1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-05 22:49:18" itemprop="dateCreated datePublished" datetime="2019-12-05T22:49:18+08:00">2019-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-16 23:09:22" itemprop="dateModified" datetime="2019-12-16T23:09:22+08:00">2019-12-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-中断设计constrains"><a href="#1-中断设计constrains" class="headerlink" title="1. 中断设计constrains"></a>1. 中断设计constrains</h1><ul>
<li>中断应该是尽量能够快速响应的，否则类似网络传输的数据可能丢失<ul>
<li>因此linux将中断处理设计成了urgent的部分+可以defer处理的部分 </li>
</ul>
</li>
<li>中断处理必须考虑重入问题，在处理一个中断时候处理其他中断</li>
<li>中断可以被屏蔽的，disabled</li>
</ul>
<h1 id="2-中断和异常"><a href="#2-中断和异常" class="headerlink" title="2. 中断和异常"></a>2. 中断和异常</h1><p>中断(interrupt)</p>
<ul>
<li>可屏蔽中断(Maskable interrupts)<ul>
<li>所有Device触发的Interrupt Requests(IRQs)都是可屏蔽中断</li>
</ul>
</li>
<li>不可屏蔽中断(Nonmaskable interrupts)<ul>
<li>一些重要的events(比如硬件故障)是不可屏蔽中断</li>
</ul>
</li>
</ul>
<p>异常(exception)</p>
<ul>
<li><p>Processor-detected exceptions: Generated when the CPU detects an anomalous condition when execution instruction. 进一步的细分成三种：</p>
<ul>
<li>Faults: 可恢复，返回当前运行的指令。跳转到前的指令存在EIP中</li>
<li>Traps: 回到下一条指令继续运行</li>
<li>Aborts: process只能被terminated，不过可以在这里检索错误现场</li>
</ul>
</li>
<li><p>可编程的异常(Programmed exceptions):  Occur at the request of the programmer.</p>
<ul>
<li>比如INT指令或者INT 3</li>
<li>into或者bound指令失败时候也会触发</li>
<li>一般被叫做software interrupts</li>
<li>一般用作系统调用或者debug</li>
</ul>
</li>
</ul>
<p>所有中断和异常使用unsigned 8bits来作为index，这个值被intel称为vector。</p>
<h1 id="3-IRQs-and-Interrupts"><a href="#3-IRQs-and-Interrupts" class="headerlink" title="3. IRQs and Interrupts"></a>3. IRQs and Interrupts</h1><p>所有的device controller都可以被指定一条或者多条Interrupt<br> ReQest(IRQ) line. 所有existing IRQ lines都被绑定到专用硬件的input pins上。这个硬件叫Programmable Interrupt Controller(可编程中断控制器)。</p>
<p> PIC的具体流程如下：</p>
<ol>
<li>检测所有连接的IRQ lines是否有raised signals。如果有多个IRQ lines被raised，那么选择lower pin的number。</li>
<li>如果有IRQ line被raise<ul>
<li>convert raised signal to对应的vector</li>
<li>将vector保存在一个Interrupt Controller I/O port，这使得cpu可以通过data bus读到这个vector</li>
<li>send一个raised signal到CPU的INTR pin，触发一个中断</li>
<li>等待cpu acknowldege the interrupt signal by writting into one of the Programmable Interrupt Controllers(PIC) I/O ports. 在此之后，clear INTR line.</li>
</ul>
<ol>
<li>回到step 1</li>
</ol>
</li>
</ol>
<p>IRQ定义从0开始，也就是IRQ0，对应的intel的vector值从32开始。但是具体的对应的关系，是可以通过编程来定义的。</p>
<p>IRQ的line是可以选择性的ignored，但是对应的signal不会被丢失，会在un-ingore时候触发该有的操作。</p>
<p>注意，这里的ignore和可屏蔽的中断的屏蔽是两个概念。EFLAGS中的IF flag的屏蔽和恢复(cli and sti)都是针对于所有IRQ lines。</p>
<p>最早的PIC设备是2片8259A芯片，支持15个IRQs(主片的IRQ2 pin接到了从片上)。同时8259A芯片不支持多核（SMP）。</p>
<h1 id="4-APIC-Advanced-Programmable-Interrupt-Controller"><a href="#4-APIC-Advanced-Programmable-Interrupt-Controller" class="headerlink" title="4. APIC (Advanced Programmable Interrupt Controller)"></a>4. APIC (Advanced Programmable Interrupt Controller)</h1><p>为了支持SMP，引入了APIC，包括：</p>
<ul>
<li>local APIC，包含LINT0和LINT1两个pin接口，在模拟8259A芯片时候，可以一个作为INTR，一个作为NMI。</li>
<li>I/O APIC，作为对接设备的LB存在，负责接收device， controller的singal，然后负责分发。也能模拟8259A芯片。</li>
<li>可编程，提供复杂的IRQ和vector的映射关系</li>
<li>同时通过各自的Interrupt Command Register(ICR)，各个core之间也可以相互发送消息（中断），称为interprocessor interrupt (IPIs)</li>
<li>I/O APIC的分发可以是static的（类似affinity），也可以使用round robin的方式。</li>
</ul>
<h1 id="5-Required-Exceptions"><a href="#5-Required-Exceptions" class="headerlink" title="5. Required Exceptions"></a>5. Required Exceptions</h1><p>vector最小的一系列exception(0-19)是intel定义，并且每个os都必须又对应的handler进行处理的。linux对于这些exception，每个注册了对应的exeption handler，这些handler大部分最终会send相对应的SIGNAL来方便其他程序监听和处理。比较有意思的几个如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Exception</th>
<th>Exception handler</th>
<th>Signal</th>
</tr>
</thead>
<tbody>
<tr>
<td>14</td>
<td>Page Fault</td>
<td>page_fault( )</td>
<td>SIGSEGV</td>
</tr>
<tr>
<td>17</td>
<td>Alignment</td>
<td>check alignment_check( )</td>
<td>SIGBUS</td>
</tr>
</tbody>
</table>
</div>
<h1 id="6-IDT"><a href="#6-IDT" class="headerlink" title="6. IDT"></a>6. IDT</h1><p>IDT中可以保存三类gate：</p>
<ul>
<li><strong>Task Gate</strong>：保存了一个TSS的段选择器，简单来说就是当这个exception handler被触发时候，会发生task的切换来进行处理</li>
<li><strong>Interrupt Gate</strong>：保存普通的段选择器+offset，用来指向对应的处理代码入口；Interrupt Gate触发时候会clear IF flag来屏蔽中断。</li>
<li><strong>Trap Gate</strong>：和Interrupt Gate一样，保存普通的段选择器+offset，但是不会屏蔽中断</li>
</ul>
<p>总体来说，Linux uses interrupt gates to handle interrupts and trap gates to handle exceptions.</p>
<h1 id="7-Interrupt-Trigger-Process"><a href="#7-Interrupt-Trigger-Process" class="headerlink" title="7. Interrupt Trigger Process"></a>7. Interrupt Trigger Process</h1><p>Trigger process</p>
<ol>
<li>从GDTR获取GDT的信息，然后取得对应的段描述符</li>
<li>比较权限，需要满足下述条件，否则throw “General Protection”:<ul>
<li>对于非用户触发的Interrupt，CPL &lt;= DPL，也就是说interrupt handler权限要不小于触发中断的程序的权限，否则无法进行处理中断。</li>
<li>对于用户触发的Interrupt，需要CPL =&gt; DPL，也就是说用户的权限要不小于触发的handler的权限，否则用户可以去调用其他的interrupt或者trap gate。</li>
</ul>
</li>
<li>如果CPL和DPL的权限不同，那就需要切换到DPL对应级别的TSS和Stack上<ul>
<li>首先读取当前的ss和esp信息（当前stack信息）</li>
<li>从需要切换到对象的TSS中读取对应的ss和esp信息</li>
<li>将当前的ss和esp信息保存在切换后的stack中</li>
</ul>
</li>
<li>如果是fault，那么需要同时需要保存cs和eip，等待handler后返回现场（逻辑地址）；最后保存eflags。如果有hardware error code，同样保存在stack上。</li>
<li>从段描述符中读取基地址，加上offset，得到目标逻辑地址并设置cs和eip，开始执行interrupt handler。</li>
</ol>
<p>在interrupt handler完成工作后，需要返回到原有的进程中，一般通过iret命令，其包括如下的操作：</p>
<ol>
<li>从当前stack上获取cs，eip和eflags。</li>
<li>如果权限之前发生过切换，那么需要恢复到原有的stack上，ss和esp同样保存在interrupt handler的stack上</li>
<li>恢复stack，恢复cs，eip和eflags</li>
<li>检查ds，es，fs和gs的DPL是否小于恢复后的CPL，如果是，那么进行清空。这是以防用户进程获取的系统权限级别的段描述符。</li>
</ol>
<h1 id="8-Interrupt-Gate"><a href="#8-Interrupt-Gate" class="headerlink" title="8. Interrupt Gate"></a>8. Interrupt Gate</h1><p>Gate类型：</p>
<ul>
<li><strong>Interrupt gate</strong><ul>
<li>DPL = 0</li>
<li>处理内部的中断(interrupt)</li>
</ul>
</li>
<li><strong>System gate</strong><ul>
<li>DPL = 3</li>
<li>vector 4(into), 5(bound)和128(int 0x80)使用这个gate</li>
</ul>
</li>
<li><strong>System interrupt gate</strong><ul>
<li>DPL = 3</li>
<li>int3, User Mode的Debug</li>
</ul>
</li>
<li><strong>Trap gate</strong><ul>
<li>DPL = 0</li>
<li>大部分内部异常(exception)依赖于这个</li>
</ul>
</li>
<li><strong>Task gate</strong><ul>
<li>DPL = 0</li>
<li>handle double fault</li>
</ul>
</li>
</ul>
<h1 id="9-IDT初始化"><a href="#9-IDT初始化" class="headerlink" title="9. IDT初始化"></a>9. IDT初始化</h1><p>5.4 kernel中和UTLK中的实现已经有所不同了</p>
<h2 id="9-1-legacy-mode"><a href="#9-1-legacy-mode" class="headerlink" title="9.1. legacy mode"></a>9.1. legacy mode</h2><p>在4.x版本中，初始化依然是通过”函数”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">oid __init trap_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	set_intr_gate(X86_TRAP_DE, divide_error);</span><br><span class="line">	set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);</span><br><span class="line">	/* int4 can be called from all */</span><br><span class="line">	set_system_intr_gate(X86_TRAP_OF, &amp;overflow);</span><br><span class="line">	set_intr_gate(X86_TRAP_BR, bounds);</span><br><span class="line">	set_intr_gate(X86_TRAP_UD, invalid_op);</span><br><span class="line">	set_intr_gate(X86_TRAP_NM, device_not_available);</span><br><span class="line">#ifdef CONFIG_X86_32</span><br><span class="line">	set_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);</span><br><span class="line">#else</span><br><span class="line">	set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set_intr_gate负责设置interrupt gate：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set_intr_gate(n, addr)</span><br><span class="line"> |- set_intr_gate_notrace(n, addr);</span><br><span class="line">    |- _set_gate(n, GATE_INTERRUPT, (<span class="keyword">void</span> *)addr, <span class="number">0</span>, <span class="number">0</span>, __KERNEL_CS);</span><br><span class="line">       |- pack_gate(&amp;s, type, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr, dpl, ist, seg);</span><br><span class="line">       |- write_idt_entry(idt_table, gate, &amp;s);</span><br><span class="line">       |- write_trace_idt_entry(gate, &amp;s); <span class="comment">// trace</span></span><br><span class="line">  |- _trace_set_gate  <span class="comment">// linux trace</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// write</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_idt_entry(dt, entry, g)		native_write_idt_entry(dt, entry, g)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">native_write_idt_entry</span><span class="params">(gate_desc *idt, <span class="keyword">int</span> entry, <span class="keyword">const</span> gate_desc *gate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;idt[entry], gate, <span class="keyword">sizeof</span>(*gate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到set_intr_gate等一些列操作，最终是往内存的一个位置(idt_table)写入对应的gate信息。</p>
<p>idt_table在head_32.S中被定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idt_descr:</span><br><span class="line">	.word IDT_ENTRIES*8-1		# idt contains 256 entries</span><br><span class="line">	.long idt_table</span><br></pre></td></tr></table></figure>
<p>对于64bit的定义在arch/x86/kernel/cpu/common.c中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line">struct desc_ptr idt_descr __ro_after_init = &#123;</span><br><span class="line">	.size = NR_VECTORS * 16 - 1,</span><br><span class="line">	.address = (unsigned long) idt_table,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>随后会被lidt命令把地址写入idtr中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The load_current_idt() must be called with interrupts disabled</span><br><span class="line"> * to avoid races. That way the IDT will always be set back to the expected</span><br><span class="line"> * descriptor. It&apos;s also called when a CPU is being initialized, and</span><br><span class="line"> * that doesn&apos;t need to disable interrupts, as nothing should be</span><br><span class="line"> * bothering the CPU then.</span><br><span class="line"> */</span><br><span class="line">static inline void load_current_idt(void)</span><br><span class="line">&#123;</span><br><span class="line">	if (is_debug_idt_enabled())</span><br><span class="line">		load_debug_idt();</span><br><span class="line">	else if (is_trace_idt_enabled())</span><br><span class="line">		load_trace_idt();</span><br><span class="line">	else</span><br><span class="line">		load_idt((const struct desc_ptr *)&amp;idt_descr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而lidt的会读取desc_ptr struct的size作为limit，address作为idt的base：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IF OperandSize = 16</span><br><span class="line">    THEN</span><br><span class="line">        IDTR(Limit) ← SRC[0:15];</span><br><span class="line">        IDTR(Base) ← SRC[16:47] AND 00FFFFFFH;</span><br><span class="line">    ELSE IF 32-bit Operand Size</span><br><span class="line">        THEN</span><br><span class="line">            IDTR(Limit) ← SRC[0:15];</span><br><span class="line">            IDTR(Base) ← SRC[16:47];</span><br><span class="line">        FI;</span><br><span class="line">    ELSE IF 64-bit Operand Size (* In 64-Bit Mode *)</span><br><span class="line">        THEN</span><br><span class="line">            IDTR(Limit) ← SRC[0:15];</span><br><span class="line">            IDTR(Base) ← SRC[16:79];</span><br><span class="line">        FI;</span><br><span class="line">FI;</span><br></pre></td></tr></table></figure>
<h2 id="9-2-kernel-version-5-4"><a href="#9-2-kernel-version-5-4" class="headerlink" title="9.2. kernel version 5.4"></a>9.2. kernel version 5.4</h2><p>5.4 kernel中初始化有改变，set_intr_gate没有了，或者说设置default idt的值不通过set_intr_gate。不过idt_table之类的还是在的，依旧做为idt的内存存储：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The default IDT entries which are set up in trap_init() before</span><br><span class="line"> * cpu_init() is invoked. Interrupt stacks cannot be used at that point and</span><br><span class="line"> * the traps which use them are reinitialized with IST after cpu_init() has</span><br><span class="line"> * set up TSS.</span><br><span class="line"> */</span><br><span class="line">static const __initconst struct idt_data def_idts[] = &#123;</span><br><span class="line">	INTG(X86_TRAP_DE,		divide_error),</span><br><span class="line">	INTG(X86_TRAP_NMI,		nmi),</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_X86_32</span><br><span class="line">	TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),</span><br><span class="line">#else</span><br><span class="line">	INTG(X86_TRAP_DF,		double_fault),</span><br><span class="line">#endif</span><br><span class="line">	INTG(X86_TRAP_DB,		debug),</span><br><span class="line"></span><br><span class="line">	SYSG(X86_TRAP_OF,		overflow),</span><br><span class="line">#if defined(CONFIG_IA32_EMULATION)</span><br><span class="line">	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),</span><br><span class="line">#elif defined(CONFIG_X86_32)</span><br><span class="line">	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，set_intr_gate变成了INTG的宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define G(_vector, _addr, _ist, _type, _dpl, _segment)	\</span><br><span class="line">	&#123;						\</span><br><span class="line">		.vector		= _vector,		\</span><br><span class="line">		.bits.ist	= _ist,			\</span><br><span class="line">		.bits.type	= _type,		\</span><br><span class="line">		.bits.dpl	= _dpl,			\</span><br><span class="line">		.bits.p		= 1,			\</span><br><span class="line">		.addr		= _addr,		\</span><br><span class="line">		.segment	= _segment,		\</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">/* Interrupt gate */</span><br><span class="line">#define INTG(_vector, _addr)				\</span><br><span class="line">	G(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL0, __KERNEL_CS)</span><br></pre></td></tr></table></figure>
<p>这里的idt_data定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct idt_data &#123;</span><br><span class="line">	unsigned int	vector;</span><br><span class="line">	unsigned int	segment;</span><br><span class="line">	struct idt_bits	bits;</span><br><span class="line">	const void	*addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而def_idts的值会在函数idt_setup_from_table中写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">idt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)</span><br><span class="line">&#123;</span><br><span class="line">	gate_desc desc;</span><br><span class="line"></span><br><span class="line">	for (; size &gt; 0; t++, size--) &#123;</span><br><span class="line">		idt_init_desc(&amp;desc, t);</span><br><span class="line">		write_idt_entry(idt, t-&gt;vector, &amp;desc);</span><br><span class="line">		if (sys)</span><br><span class="line">			set_bit(t-&gt;vector, system_vectors);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该这么多是为了保证代码整洁，原来的32和64bit定义分开，这里统一到了一起。</p>
<h2 id="9-3-ignore-irq-handler"><a href="#9-3-ignore-irq-handler" class="headerlink" title="9.3. ignore irq handler"></a>9.3. ignore irq handler</h2><p>在irq handler初始化之前，所有的对应的idt entry都会被设置成 head_32.S中的early_ignore_irq(老版本是ignore_int)，代码基本一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* This is the default interrupt &quot;handler&quot; :-) */</span><br><span class="line">ENTRY(early_ignore_irq)</span><br><span class="line">	cld</span><br><span class="line">#ifdef CONFIG_PRINTK</span><br><span class="line">	pushl %eax</span><br><span class="line">	pushl %ecx</span><br><span class="line">	pushl %edx</span><br><span class="line">	pushl %es</span><br><span class="line">	pushl %ds</span><br><span class="line">	movl $(__KERNEL_DS),%eax</span><br><span class="line">	movl %eax,%ds</span><br><span class="line">	movl %eax,%es</span><br><span class="line">	cmpl $2,early_recursion_flag</span><br><span class="line">	je hlt_loop</span><br><span class="line">	incl early_recursion_flag</span><br><span class="line">	pushl 16(%esp)</span><br><span class="line">	pushl 24(%esp)</span><br><span class="line">	pushl 32(%esp)</span><br><span class="line">	pushl 40(%esp)</span><br><span class="line">	pushl $int_msg</span><br><span class="line">	call printk</span><br><span class="line"></span><br><span class="line">	call dump_stack</span><br><span class="line"></span><br><span class="line">	addl $(5*4),%esp</span><br><span class="line">	popl %ds</span><br><span class="line">	popl %es</span><br><span class="line">	popl %edx</span><br><span class="line">	popl %ecx</span><br><span class="line">	popl %eax</span><br><span class="line">#endif</span><br><span class="line">	iret</span><br></pre></td></tr></table></figure>
<h2 id="9-4-Typical-Exception-Handler-Process"><a href="#9-4-Typical-Exception-Handler-Process" class="headerlink" title="9.4 Typical Exception Handler Process"></a>9.4 Typical Exception Handler Process</h2><p>基本的exception处理流程包括如下几步：</p>
<ul>
<li>保存error code，jmp到通用的exception handler流程<ul>
<li>legacy mode: error_code</li>
<li>latest(5.4): common_exception</li>
</ul>
</li>
<li>通用的exception handler流程会首先保存context</li>
<li>调用对应的c代码的handler(地址保存在%edi中)</li>
<li>调用ret_from_exception开始返回</li>
<li>调用restore_all_kernel</li>
<li>检查是否有中断</li>
<li>恢复stack frame随后iret</li>
</ul>
<p>更加完整的流程描述如下：</p>
<ol>
<li>Saves the registers that might be used by the high-level C function on the stack.</li>
<li>Issues a cld instruction to clear the direction flag DF of eflags, thus making sure<br>that autoincreases on the edi and esi registers will be used with string<br>instructions.*</li>
<li>Copies the hardware error code saved in the stack at location esp+36 in edx.<br>Stores the value –1 in the same stack location. As we’ll see in the section “Reexecution of System Calls” in Chapter 11, this value is used to separate 0x80 exceptions from other exceptions.</li>
<li>Loads edi with the address of the high-level do_handler_name( ) C function<br>saved in the stack at location esp+32; writes the contents of es in that stack<br>location.</li>
<li>Loads in the eax register the current top location of the Kernel Mode stack. This<br>address identifies the memory cell containing the last register value saved in<br>step 1.</li>
<li>Loads the user data Segment Selector into the ds and es registers.</li>
<li>Invokes the high-level C function whose address is now stored in edi.</li>
</ol>
<p>以下，举处除零的handler为例。</p>
<h3 id="9-4-1-Legacy-do-divide-error实现"><a href="#9-4-1-Legacy-do-divide-error实现" class="headerlink" title="9.4.1. Legacy do_divide_error实现"></a>9.4.1. Legacy do_divide_error实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(divide_error)</span><br><span class="line">	RING0_INT_FRAME</span><br><span class="line">	ASM_CLAC</span><br><span class="line">	pushl_cfi $0			# no error code</span><br><span class="line">	pushl_cfi $do_divide_error</span><br><span class="line">	jmp error_code</span><br><span class="line">	CFI_ENDPROC</span><br><span class="line">END(divide_error)</span><br></pre></td></tr></table></figure>
<p>error_code是共享的处理流程，其中会调用到do_divide_error函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error_code:</span><br><span class="line">    ... # push registers</span><br><span class="line"></span><br><span class="line">	cld</span><br><span class="line">	</span><br><span class="line">	... # build up do_divide_error function stack</span><br><span class="line">	 </span><br><span class="line">	call *%edi # call do_divide_error function</span><br><span class="line">	jmp ret_from_exception</span><br><span class="line">	CFI_ENDPROC</span><br><span class="line">END(page_fault)</span><br></pre></td></tr></table></figure>
<p>do_divide_error是个c程序，定义在traps.c中的宏DO_ERROR_INFO，最终会调用do_trap来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr)		\</span></span><br><span class="line">dotraplinkage <span class="keyword">void</span> do_#<span class="meta">#name(struct pt_regs *regs, long error_code)	\</span></span><br><span class="line">&#123;									\</span><br><span class="line">	...</span><br><span class="line">	conditional_sti(regs);						\</span><br><span class="line">	do_trap(trapnr, signr, str, regs, error_code, &amp;info);		\</span><br><span class="line">	exception_exit(prev_state);					\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do_trap</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __kprobes</span><br><span class="line">do_trap(<span class="keyword">int</span> trapnr, <span class="keyword">int</span> signr, <span class="keyword">char</span> *str, struct pt_regs *regs,</span><br><span class="line">	<span class="keyword">long</span> error_code, <span class="keyword">siginfo_t</span> *info)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info)</span><br><span class="line">		force_sig_info(signr, info, tsk);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		force_sig(signr, tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步是想当前程序发送一个SIGFPE signal。ret_from_exception和5.4版本中功能类似，后面一起讲。</p>
<h3 id="9-4-2-Linux-5-4-kernel实现："><a href="#9-4-2-Linux-5-4-kernel实现：" class="headerlink" title="9.4.2. Linux 5.4 kernel实现："></a>9.4.2. Linux 5.4 kernel实现：</h3><h4 id="9-4-2-1-32bit-divide-error"><a href="#9-4-2-1-32bit-divide-error" class="headerlink" title="9.4.2.1. 32bit divide_error"></a>9.4.2.1. 32bit divide_error</h4><p>代码在entry_32.S中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(divide_error)</span><br><span class="line">	ASM_CLAC</span><br><span class="line">	pushl	$0				# 这里保存error code，0代表没有</span><br><span class="line">	pushl	$do_divide_error  # 这里保存目标c程序地址</span><br><span class="line">	jmp	common_exception</span><br><span class="line">END(divide_error)</span><br></pre></td></tr></table></figure>
<p>common_exception是通用的exception处理流程（除了double fault）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">common_exception:</span><br><span class="line">	/* the function address is in %gs&apos;s slot on the stack */</span><br><span class="line">	SAVE_ALL switch_stacks=1 skip_gs=1</span><br><span class="line">	ENCODE_FRAME_POINTER</span><br><span class="line">	UNWIND_ESPFIX_STACK</span><br><span class="line"></span><br><span class="line">	/* fixup %gs */</span><br><span class="line">	GS_TO_REG %ecx</span><br><span class="line">	movl	PT_GS(%esp), %edi		# get the function address</span><br><span class="line">	REG_TO_PTGS %ecx</span><br><span class="line">	SET_KERNEL_GS %ecx</span><br><span class="line"></span><br><span class="line">	/* fixup orig %eax */</span><br><span class="line">	movl	PT_ORIG_EAX(%esp), %edx		# get the error code</span><br><span class="line">	movl	$-1, PT_ORIG_EAX(%esp)		# no syscall to restart</span><br><span class="line"></span><br><span class="line">	TRACE_IRQS_OFF</span><br><span class="line">	movl	%esp, %eax			# pt_regs pointer</span><br><span class="line">	CALL_NOSPEC %edi          # 跳转到对应的c历程</span><br><span class="line">	jmp	ret_from_exception</span><br><span class="line">END(common_exception)</span><br></pre></td></tr></table></figure>
<p>除去一堆保存环境和测试的，这里要关注的就是跳转到c handler的代码。</p>
<h4 id="9-4-2-2-64bit-divide-error实现"><a href="#9-4-2-2-64bit-divide-error实现" class="headerlink" title="9.4.2.2. 64bit divide_error实现"></a>9.4.2.2. 64bit divide_error实现</h4><p>代码在entry_64.S中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idtentry divide_error			do_divide_error			has_error_code=0</span><br><span class="line"></span><br><span class="line">// idtentry - Generate an IDT entry stub</span><br></pre></td></tr></table></figure>
<p>idtentry: generates an IDT stub that sets up a usable kernel context, creates struct pt_regs, and calls @do_sym. </p>
<h4 id="9-4-2-2-c-handler"><a href="#9-4-2-2-c-handler" class="headerlink" title="9.4.2.2 c handler"></a>9.4.2.2 c handler</h4><p>do_divide_error实现在arch\x86\kernel\traps.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP ((void __user *)uprobe_get_trap_addr(regs))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DO_ERROR(trapnr, signr, sicode, addr, str, name)		   \</span></span><br><span class="line">dotraplinkage <span class="keyword">void</span> do_#<span class="meta">#name(struct pt_regs *regs, long error_code)	   \</span></span><br><span class="line">&#123;									   \</span><br><span class="line">	do_error_trap(regs, error_code, str, trapnr, signr, sicode, addr); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DO_ERROR(X86_TRAP_DE,     SIGFPE,  FPE_INTDIV,   IP, <span class="string">"divide error"</span>,        divide_error)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_error_trap</span><span class="params">(struct pt_regs *regs, <span class="keyword">long</span> error_code, <span class="keyword">char</span> *str,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">long</span> trapnr, <span class="keyword">int</span> signr, <span class="keyword">int</span> sicode, <span class="keyword">void</span> __user *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCU_LOCKDEP_WARN(!rcu_is_watching(), <span class="string">"entry code didn't wake RCU"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * WARN*()s end up here; fix them up before we call the</span></span><br><span class="line"><span class="comment">	 * notifier chain.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!user_mode(regs) &amp;&amp; fixup_bug(regs, trapnr))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) !=</span><br><span class="line">			NOTIFY_STOP) &#123;</span><br><span class="line">		cond_local_irq_enable(regs);</span><br><span class="line">		do_trap(trapnr, signr, str, regs, error_code, sicode, addr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，这里也会调用的通用do_trap实现中去。</p>
<h2 id="9-5-返回"><a href="#9-5-返回" class="headerlink" title="9.5. 返回"></a>9.5. 返回</h2><p>完成调用以后，ret_from_exception负责返回到原来进程中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ret_from_exception</span><br><span class="line">  - restore_all_kernel</span><br><span class="line">    - .Lno_preempt</span><br><span class="line">      - .Lirq_return</span><br><span class="line">        - IRET_FRAME -&gt; 回复堆栈</span><br><span class="line">        - INTERRUPT_RETURN -&gt; iret 或者 jmp native_iret</span><br></pre></td></tr></table></figure>
<h1 id="10-中断-Interrupt"><a href="#10-中断-Interrupt" class="headerlink" title="10. 中断(Interrupt)"></a>10. 中断(Interrupt)</h1><ul>
<li>异常最终的操作基本都是发signal给当前的进程，这是因为异常的发生往往是in time的。</li>
<li>但是对于中断，中断的trigger往往是异步的，触发时候目标进程可能在sleep状态，也就是说当前进程不是中断的目标进程。</li>
</ul>
<p>中断细节可以分成如下几类：</p>
<ul>
<li>I/O interrupts</li>
<li>Timer interrupts<ul>
<li>local APIC timer or an external timer</li>
</ul>
</li>
<li>Interprocessor interrupts</li>
</ul>
<h2 id="10-1-I-O-interrupts"><a href="#10-1-I-O-interrupts" class="headerlink" title="10.1. I/O interrupts"></a>10.1. I/O interrupts</h2><p>多台设备可能绑在同一个I/O interrupt上，使用同一条IRQ line。此时，需要一种分享的方式，一般有两种方式：</p>
<ul>
<li>IRQ sharing: 多个设备使用同一个interrupt service routines (ISRs)，这个routine需要去判断到底哪一个设备发送了中断。</li>
<li>IRQ dynamic allocation: 一次只让一个设备使用，只有激活状态的设备可以尝试独占IRQ line。</li>
</ul>
<p>另一方面，对于中断处理程序，因为其会屏蔽中断，并且可能被switch出去，所以linux会把中断处理后可能的操作分成三类：</p>
<ul>
<li>Critical</li>
<li>Noncritical</li>
<li>Noncritical deferrable</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/21/wild-pig-chapter3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/21/wild-pig-chapter3/" class="post-title-link" itemprop="url">野猪书第三章读书笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-21 14:10:59" itemprop="dateCreated datePublished" datetime="2019-11-21T14:10:59+08:00">2019-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-05 23:04:13" itemprop="dateModified" datetime="2019-12-05T23:04:13+08:00">2019-12-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-overview"><a href="#1-overview" class="headerlink" title="1. overview"></a>1. overview</h1><p>数据库分类</p>
<ul>
<li>事务处理型</li>
<li>数据分析型</li>
</ul>
<p>存储索引家族：</p>
<ul>
<li>日志结构的存储引擎</li>
<li>面向页的存储引擎，比如b-tree</li>
</ul>
<h1 id="2-哈希表索引"><a href="#2-哈希表索引" class="headerlink" title="2. 哈希表索引"></a>2. 哈希表索引</h1><p>核心：将key hash到对应的文件位置</p>
<ul>
<li>使用日志方式，不修改已有记录，在末尾增加<ul>
<li>如果能够保持key在内存中，那么写入速度会很快</li>
</ul>
</li>
<li>将日志分段，到一定大小，生成新的段<ul>
<li>在合适时机进行段合并，只保留最新的结果</li>
<li>使用后台线程，在完成合并之前使用老的index</li>
<li>合并之后切换到新的index，删除老的index</li>
</ul>
</li>
<li>最终，每一个段都会有自己的索引（注意，可能有多个段）<ul>
<li>搜索需要从最新的段开始往前找索引表</li>
</ul>
</li>
</ul>
<p>在实现中还需要考虑：</p>
<ul>
<li>文件格式：二进制 &gt; CSV</li>
<li>删除记录：可以通过标记，在合并时候处理被删除的key</li>
<li>崩溃回复：如果重启引起内存中的key map丢失，可以<ul>
<li>从头开始扫描文件，重建key map</li>
<li>或者在平时就定时将key map映射到磁盘之上</li>
</ul>
</li>
<li>部分写入的记录：写日志中也有可能崩溃，加入校验值来发现损坏情况。</li>
<li>并发控制：因为段是需要严格顺序写入的，因此<ul>
<li>写必须是单线程</li>
<li>读可以多线程</li>
</ul>
</li>
</ul>
<p>为什么之追加不直接修改文件：</p>
<ul>
<li>顺序写性能会好很多，特别对于HDD。但是对于SSD或者nvme磁盘如何呢？</li>
<li>因为追加是只读的，因此兵法和崩溃恢复都简单很多。</li>
<li>合并旧段可以减轻文件碎片化问题</li>
</ul>
<p>哈希表索引局限性：</p>
<ul>
<li>索引哈希表必须全部放入内存，如果spill到磁盘上，性能会收到影响；另外，哈希变满时候，哈希冲突会影响性能。</li>
<li>区间查询效率不高：就是说相邻的key的value值分布基本不会是相邻的，因此扫描一个range的keys，需要逐个查找其中的每一个key。<ul>
<li>换句话说，你没办法知道range中哪些key是存在的，只能一个一个测试。</li>
</ul>
</li>
</ul>
<h1 id="3-SSTable索引"><a href="#3-SSTable索引" class="headerlink" title="3. SSTable索引"></a>3. SSTable索引</h1><p>哈希表索引中保存在文件中的key-value值对是不排序的，出现的顺序基本是按照写入的顺序的来的，无论是原始文件还是合并后的文件。</p>
<p>如果我们要求磁盘上的文件值对，都是按照key的顺序来保存。那么会有如下好处：</p>
<ul>
<li>合并两个segment file会变得高效</li>
<li>内存中的索引不需要保存所有key的索引信息，只需要保存几个作为标点的key的索引，其他key可通过区间扫描来寻找。在区间不大时候，需要扫描的range是有限的，性能方面也是非常快的。</li>
<li>文件可以进行压缩，我们只需要记录segment的start和end的key</li>
</ul>
<p>如何实现：</p>
<ul>
<li>在内存中引入排序结构，比如红黑树或者AVL-tree，在抵达threshold之后写入磁盘</li>
<li>查找的时候按照先内存后磁盘的方法进行搜寻</li>
<li>定时后台合并文件</li>
<li>为了支持崩溃恢复，可以为内存中的数据额外做一份普通的日志来作为恢复使用</li>
</ul>
<h2 id="3-1-LSM-Tree"><a href="#3-1-LSM-Tree" class="headerlink" title="3.1. LSM-Tree"></a>3.1. LSM-Tree</h2><p>所有类似这种排序后的segment file合并的结构都可以称之LSM-Tree(Log-structured merge-tree)。</p>
<p>包括LevelDB,RocksDB和Cassandra，Hbase都有LSM-tree的影子。另外ES以来的Lucence索引引擎，也用了类似的逻辑：倒排索引按照key的顺序保存在文件中，通过额外的索引的索引来快速搜索这些倒排索引。</p>
<p>注意SSTable是索引，LSM-Tree是真正存储数据的文件结构。</p>
<h2 id="3-2-优化"><a href="#3-2-优化" class="headerlink" title="3.2. 优化"></a>3.2. 优化</h2><p>最坏情况下，如果某个key不存在或者key只存在最老的segment中时候，需要触发一次全segment文件的扫描操作。对于key不存在的情况，引入blooming filter，保证如果filter告诉你不存在，保证key确实不存在。</p>
<p>对于后者，SSTable的压缩和合并逻辑会有一些影响，有两种合并逻辑：</p>
<ul>
<li>大吞小</li>
<li>分层合并：将旧的数据分到单独的层级，然后进行合并</li>
</ul>
<h1 id="4-B-Tree"><a href="#4-B-Tree" class="headerlink" title="4. B-Tree"></a>4. B-Tree</h1><p>B-Tree将数据和索引分成固定大小的数据块，一般为4KB（配合x86的默认页大小4KB），然后将数据块们组织成树形结构。注意这里，B-Tree保存的是索引信息，每一个叶子节点保存了某个值的具体位置信息。</p>
<p>参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">B-Tree</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></li>
</ul>
<p>简单来说，一个M维度的B-Tree节点可以如此描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">    int numberKeys;</span><br><span class="line">    string keys[M - 1];</span><br><span class="line">    object values[M - 1];</span><br><span class="line">    struct Node children[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外有一些约束来保证B-Tree的搜索性能，对于一棵order为m的树（最多有m个子节点）：</p>
<ul>
<li>任何节点如果有k个key，那么就有k+1个ref</li>
<li>除了叶子节点，每一层至少是半满的，也就是至少有[m/2]个key和key+1的ref；最多有有m-1个key和m个ref</li>
<li>每个internal 节点至少有2个子节点（2个ref）</li>
</ul>
<p>在这种情况下，整棵树的高度可以限制在(N为key的个数）：</p>
<script type="math/tex; mode=display">
H = \frac{log_{[m/2]}(N+1)}{2}</script><p>注意一棵b树的每个节点既保存key对应的值，又保存了ref的信息。</p>
<h2 id="4-1-B-Tree容错"><a href="#4-1-B-Tree容错" class="headerlink" title="4.1 B-Tree容错"></a>4.1 B-Tree容错</h2><p>B-Tree一般使用预写日志(write-ahead, WAL)，先写日志，再写Tree。</p>
<p>多线程情况下， B-Tree不像LSM-Tree那么容易。</p>
<h2 id="4-2-B-Tree优化"><a href="#4-2-B-Tree优化" class="headerlink" title="4.2 B-Tree优化"></a>4.2 B-Tree优化</h2><ul>
<li>写时复制</li>
<li>B+ Tree，也就是在internal节点不保存具体节点的值，只保存ref或者其他索引信息；在叶子节点才保存具体的值。这样做的另外一个好处是可以把非叶子节点都加载到内存中。</li>
<li>slibing节点直接可以增加额外的ref来快速遍历</li>
<li>分形树（FTI，Fractal Tree Indexes）<ul>
<li>为叶子节点增加存储数据的buffer，组织成一棵树</li>
<li>为节点增加Message buffer，用于缓冲读写请求</li>
</ul>
</li>
</ul>
<h2 id="5-LSM-Tree和B-Tree比较"><a href="#5-LSM-Tree和B-Tree比较" class="headerlink" title="5. LSM-Tree和B-Tree比较"></a>5. LSM-Tree和B-Tree比较</h2><p>写放大：合并数据时候引入的额外写入。</p>
<p>LSM-Tree优势：</p>
<ul>
<li>有时候具有较低的写放大</li>
<li>顺序写人更加好的cache效率</li>
<li>更好的压缩和更少的碎片</li>
</ul>
<p>LSM-Tree缺点：</p>
<ul>
<li>后台合并操作影响前台读写性能，相对而言，B-Tree的性能更加稳定</li>
<li>高吞吐量时候，如果后台合并速度跟不上，磁盘空间最终会被吃完。</li>
<li>B-Tree更好的支持锁机制。在许多关系数据库中，事务隔离是通过key范围上的锁来实现的。</li>
</ul>
<h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h2><h3 id="6-1-二级索引"><a href="#6-1-二级索引" class="headerlink" title="6.1. 二级索引"></a>6.1. 二级索引</h3><p>除了主索引外的额外索引，但是会有key重复的问题。一般通过拼凑其他信息来使得key唯一。</p>
<h3 id="6-2-堆文件"><a href="#6-2-堆文件" class="headerlink" title="6.2. 堆文件"></a>6.2. 堆文件</h3><p>一般索引中不保存具体的值，只是保存一个ref信息或者位置信息，具体的内容保存在堆文件中。</p>
<p>在更新时候，如果新值不大于旧值，那么直接覆盖就可以了；否则需要重新分配空间，并且所有指向这个值的ref信息都需要更新或者留下一个指向新位置的间接跳转信息。</p>
<h3 id="6-3-聚集索引"><a href="#6-3-聚集索引" class="headerlink" title="6.3. 聚集索引"></a>6.3. 聚集索引</h3><p>索引中直接保存具体的值。另外有保存部分值的覆盖索引或者包含列索引。（类似cache）</p>
<p>无论那种都可以提高读取性能，代价是复杂的插入和事务同步问题。</p>
<h3 id="6-4-多列索引"><a href="#6-4-多列索引" class="headerlink" title="6.4. 多列索引"></a>6.4. 多列索引</h3><p>对于多列进行合并索引。</p>
<ul>
<li>级联索引</li>
</ul>
<p>把多个列合并拼接起来作为一个key索引。对于A+B拼接的，可以对于A+B或者A进行快速索引，但是没有办法对B单独进行快速索引。</p>
<ul>
<li>多维索引</li>
</ul>
<p>对于多个列进行真正的索引。传统的B-Tree和LSM-Tree都没有办法高效的应对这种查询。</p>
<h4 id="6-4-1-R-Tree"><a href="#6-4-1-R-Tree" class="headerlink" title="6.4.1. R-Tree"></a>6.4.1. R-Tree</h4><p>R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据创建索引。</p>
<p>类似于B-Tree，R-Tree将空间划分成多个子空间（类似于一个range），然后继续划分直到最终值，效果如下：</p>
<p><img src="rtree.png" alt="image"></p>
<p>与此相关的还有其他的名为空间索引的机制：</p>
<p>参考文章</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/news/199266" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/199266</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/38597148" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38597148</a></li>
</ul>
<p>空间索引列表：</p>
<ul>
<li>GeoHash</li>
<li>kd-tree</li>
<li>Grid index</li>
<li>四叉树/八叉树</li>
<li>Space filling curve：通过一条线来描述空间上的所有位置，二维值可以转化成单个值</li>
</ul>
<p><img src="spaceFill.png" alt="image"></p>
<ul>
<li>LSH（Locality Sensitive Hashing</li>
</ul>
<h3 id="6-5-全文搜索"><a href="#6-5-全文搜索" class="headerlink" title="6.5. 全文搜索"></a>6.5. 全文搜索</h3><p>全文搜索不同于之前的索引有明显的范围。全文搜索往往是模糊的。</p>
<p>lucene通过给key构建前缀树来提供key的模糊搜索。</p>
<h2 id="7-内存数据库"><a href="#7-内存数据库" class="headerlink" title="7. 内存数据库"></a>7. 内存数据库</h2><ul>
<li>随机访问 -&gt; 可以使用磁盘没有办法高效实用的数据结构</li>
<li>易失性 -&gt; NVM</li>
</ul>
<p>标准产品：</p>
<ul>
<li>redis</li>
<li>RAMCloud</li>
</ul>
<h2 id="8-事务处理（OLTP，online-transaction-processing"><a href="#8-事务处理（OLTP，online-transaction-processing" class="headerlink" title="8. 事务处理（OLTP，online transaction processing)"></a>8. 事务处理（OLTP，online transaction processing)</h2><p>OLTP类似于传统的SQL引擎，查询没有固定的format，更多是ad-hoc(online)的查询。OLAP（online analytic processing），类似于数据仓库。OLTP的索引更多使用上述提到的索引；OLAP需要新设计的索引。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property</th>
<th>Transaction processing systems (OLTP)</th>
<th>Analytic systems (OLAP)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>Main read pattern |Small number of records per query, fetched by key |Aggregate over large number of records<br>Main write pattern |Random-access, low-latency writes from user input |Bulk import (ETL) or event stream<br>Primarily used by |End user/customer, via web application |Internal analyst, for decision support<br>What data represents |Latest state of data (current point in time) |History of events that happened over time<br>Dataset size |Gigabytes to terabytes |Terabytes to petabytes</p>
<p>典型的数据仓库</p>
<ul>
<li>Terdata</li>
<li>Vertica</li>
<li>SAP HAHA</li>
<li>Hadoop系列</li>
</ul>
<h2 id="9-列式存储"><a href="#9-列式存储" class="headerlink" title="9. 列式存储"></a>9. 列式存储</h2><ul>
<li>按照列的方式来存储数据，而不是传统的整行的顺序</li>
<li>只需要关注几列 -&gt; 更少的数据读取和更快的读取速度</li>
<li>方便压缩<ul>
<li>位图进一步的游程(Run-Length)编码</li>
</ul>
</li>
<li>cache &amp; memory friend，并且可以使用SIMD指令</li>
<li>列式存储的排序和索引</li>
</ul>
<p>HBase列簇中的数据式按照行来存储的。</p>
<h2 id="10-Data-Cubes-and-Materialized-Views-物化视图"><a href="#10-Data-Cubes-and-Materialized-Views-物化视图" class="headerlink" title="10.  Data Cubes and Materialized Views(物化视图)"></a>10.  Data Cubes and Materialized Views(物化视图)</h2><p>物化会提前计算出一些结果然后保存下来。Data Cube就是按照各种不同维度聚合形成的数据块。</p>
<ul>
<li>优势是预先计算能获得好的性能提升。</li>
<li>劣势缺乏灵活性和额外的存储空间。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/RSIC-V-RV32I-Instruction-Set/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/18/RSIC-V-RV32I-Instruction-Set/" class="post-title-link" itemprop="url">RSIC-V RV32I Instruction Set</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-18 22:28:50" itemprop="dateCreated datePublished" datetime="2019-11-18T22:28:50+08:00">2019-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-16 23:09:45" itemprop="dateModified" datetime="2019-12-16T23:09:45+08:00">2019-12-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Instruction-Length"><a href="#1-Instruction-Length" class="headerlink" title="1. Instruction Length"></a>1. Instruction Length</h1><p>RISC-V指令是定长的32bit，但是拓展可以支持变长。变长一定是16bit的整数倍。</p>
<p>encoding convension要求所有32bit指令长度的命令最低两位一定是11. 注意RISC-V是小端的指令集。对于&gt;32bit长度的指令格式，同样要求满足这个要求，因此对于16bit指令长度，要求最低两位一定不是11。</p>
<p>当然对于non-standard指令格式，RISC-V可以是大端的。 </p>
<h1 id="2-RV32I"><a href="#2-RV32I" class="headerlink" title="2. RV32I"></a>2. RV32I</h1><p>RV32I是最基础的指令集，也是任何RISC-V实现必须实现的指令集。RV32I包括了47条独特指令，另外，实现可以选择使用总是trap的系统（SYSTEM）硬件指令代替 8 条 SCALL / SBREAK / RD* 指令，可以讲指令集减少到40条；如果还能够实现FENCE和FENC.I，那么可以将指令总数减少到38条。RV32I 能够模拟几乎所有的 ISA 扩展（除了 A 扩展，它需要额外的硬件来支持原子性（atomicity））。</p>
<blockquote>
<p>RV32I was designed to be sufficient to form a compiler target and to support modern operating system environments. The ISA was also designed to reduce the hardware required in a minimal implementation. RV32I contains 47 unique instructions, though a simple implementation might cover the eight SCALL/SBREAK/CSRR* instructions with a single SYSTEM hardware instruction that always traps and might be able to implement the FENCE and FENCE.I instructions as NOPs, reducing hardware instruction count to 38 total. RV32I can emulate almost any other ISA extension (except the A extension, which requires additional hardware support for atomicity).</p>
</blockquote>
<p>RV32I包括了32个32bit的通用寄存器(x0-x31)外加一个用户可见的pc寄存器。32个通用寄存器其中x0固定为全0，x1一般用于保存返回值。详细的register convension参考较早文章。</p>
<h2 id="2-1-opcode-layout"><a href="#2-1-opcode-layout" class="headerlink" title="2.1. opcode layout"></a>2.1. opcode layout</h2><p>RISC-V设计几个理念：</p>
<ul>
<li>所有的layout格式尽量共享位置的意义的定义<ul>
<li>比如所有的指令的r0，r1，rd位置都固定index</li>
</ul>
</li>
<li>尽量减少指令额外的计算，比如预先进行shift，只使用符号扩展</li>
</ul>
<p>RV32I包括了4种基本格式(R/I/S/U)和两种变化格式(B/J)：</p>
<p><img src="RV32I-Layout.png" alt=""></p>
<p>可以看到寄存器的位置是固定的。</p>
<h2 id="2-2-整数指令"><a href="#2-2-整数指令" class="headerlink" title="2.2. 整数指令"></a>2.2. 整数指令</h2><p>首先需要注意到，opcode的长度是8个bit，去掉固定为11的最低两位，能用的opcode长度是6bit，也就是说最多支持2^6=64条指令。但实际上，RV32I中的很多指令是公用opcode的，通过额外参数来区分具体的action。</p>
<p>比如ADD和SUB就共享opcode。完整的列表如下：</p>
<p><img src="RV32I-Instr-List.png" alt="image"></p>
<ul>
<li>LUI: load imm into register</li>
<li>AUIPC: add imm to pc</li>
<li>JAL: unconditional direct jump</li>
<li>JALR: unconditional indirect jump</li>
<li>BEQ: conditional branch when equal</li>
<li>BNE: conditional branch when not equal</li>
<li>BLT: conditional branch when r1 &lt; r2</li>
<li>BGE: conditional branch when r1 &gt; r2</li>
<li>BLTU: conditional branch when r1 &lt; r2 as unsinged</li>
<li>BGEU: conditional branch when r1 &gt; r2 as unsinged</li>
<li>LB: load 8bit value from memory into register</li>
<li>LH: load 16bit value from memory into register</li>
<li>LW: load 32bit value from memory into register</li>
<li>LBU: load 8bit unsigned value from memory into register</li>
<li>LHU: load 16bit unsigned value from memory into register</li>
<li>SB: store 8bit value from register to memory</li>
<li>SH: store 16bit value from register to memory</li>
<li>SW: store 32bit value from register to memory</li>
<li>ADDI: adds the sign-extended 12-bit immediate with r1 to rd</li>
<li>SLTI: put 1 into register if r1 &lt; signed extend imm otherwise 0</li>
<li>SLTIU: put 1 into register if r1 &lt; r2 extend imm as unsigned otherwise 0</li>
<li>XORI: xor the sign-extended 12-bit immediate with r1 to rd</li>
<li>ORI: or the sign-extended 12-bit immediate with r1 to rd</li>
<li>ANDI: and the sign-extended 12-bit immediate with r1 to rd</li>
<li>SLLI: logical left shift register value imm bits</li>
<li>SRLI: logical right shift register value imm bits</li>
<li>SRAI: arithmetic right shift register value imm bits<br>shift</li>
<li>ADD: add</li>
<li>SUB: sub</li>
<li>SLL: logical left shift r1 value <strong>low 5 bits</strong> value of r2</li>
<li>SLT: put 1 into register if r1 &lt; r2 otherwise 0</li>
<li>SLTU: put 1 into register if r1 &lt; r2 as unsignedotherwise 0</li>
<li>XOR: xor</li>
<li>SRL: logical right shift r1 value <strong>low 5 bits</strong> value of r2</li>
<li>SRA: arithmetic right shift r1 value <strong>low 5 bits</strong> value of r2</li>
<li>OR: or</li>
<li>AND: and</li>
<li>FENCE: memory fence</li>
<li>ECALL：Trap to System Call</li>
<li>EBREAK: DEBUG mode break</li>
</ul>
<p>一些注解</p>
<ul>
<li><strong>RISC-V的FENCE可以玩组合:</strong></li>
</ul>
<blockquote>
<p>Any combination of device input (I), device output (O), memory reads (R), and memory writes (W) may be ordered with respect to any combination of the same. </p>
</blockquote>
<ul>
<li><strong>RISC-V是没有Overflow Flag:</strong></li>
</ul>
<p>下面引自官方文档：</p>
<p>We did not include special instruction-set support for overflow checks on integer arithmetic operations in the base instruction set, as many overflow checks can be cheaply implemented using RISC-V branches. Overflow checking for unsigned addition requires only a single additional branch instruction after the addition: <code>add t0, t1, t2; bltu t0, t1, overflow</code>.</p>
<p>For signed addition, if one operand’s sign is known, overflow checking requires only a single branch after the addition: <code>addi t0, t1, +imm; blt t0, t1, overflow</code>. This covers the common case of addition with an immediate operand.</p>
<p>For general signed addition, three additional instructions after the addition are required, leveraging the observation that the sum should be less than one of the operands if and only if the other operand is negative.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add t0, t1, t2</span><br><span class="line">slti t3, t2, 0</span><br><span class="line">slt t4, t0, t1</span><br><span class="line">bne t3, t4, overflow</span><br></pre></td></tr></table></figure>
<p>In RV64I, checks of 32-bit signed additions can be optimized further by comparing the results of ADD and ADDW on the operands.</p>
<p>简单来说，检查是否overflow没有flag给你用（为了简化电路设计，另外overflow用处不大），而是用指令+branch来进行判断，详细而言分成3中情况：</p>
<ol>
<li>unsigned相加，那么没有overflow意味着 rd &gt; r1 &amp;&amp; rd &gt; r2，当然对于imm版本只需要检测rd &gt; r1</li>
<li>signed imm相加，如果imm符号知道，那么判断rd &gt; r1或者rd &lt; r1</li>
<li>剩下的就需要好几条指令来判断了</li>
</ol>
<ul>
<li><strong>NOP命令:</strong></li>
</ul>
<p>不存在的，可以用ADD r1, r1, r0来代替。拓展指令集可能加入单独的NOP指令。</p>
<ul>
<li><strong>状态寄存器:</strong></li>
</ul>
<p>不存在的+1。老版本的文档将CSR相关命令列到RV32I下面；当前文档(draft-20191114-0777770)单独拆到了一章：“Zicsr”, Control and Status Register<br>(CSR) Instructions, Version 2.0</p>
<p>因此也不存在用于比较的EFLAGS，所有的条件跳转都是比较具体的两个寄存器或者寄存器和imm的值。</p>
<p>说到底也是为了简化系统的设计。</p>
<h1 id="3-RV64I"><a href="#3-RV64I" class="headerlink" title="3. RV64I"></a>3. RV64I</h1><p>和RV64I非常类似，差别在于：</p>
<ul>
<li>寄存器宽度变成了64bit</li>
<li>扩展了64bit宽度的指令LD/SD (double word)</li>
<li>增加了单独处理32bit的指令(ADD之类的现在等是64bit的)<ul>
<li>ADDIW/SLLW/SRLW/SUBW/SRAW</li>
<li>注意移位操作offset bits还是5bit</li>
</ul>
</li>
<li>移位操作的offset bits因为64bit=32bit*2，从5bit”升级”成6bit</li>
</ul>
<p>其实RV128I指令集的拓展也类似，理论上可以拓展到imm无法支持offset bits的描述，但在此之前，量子计算机应该出来吧。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf" target="_blank" rel="noopener">https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf</a></li>
<li><a href="https://github.com/riscv/riscv-isa-manual" target="_blank" rel="noopener">risc-v manual</a>: <a href="https://github.com/riscv/riscv-isa-manual" target="_blank" rel="noopener">https://github.com/riscv/riscv-isa-manual</a></li>
<li><a href="http://gfiles.chinaaet.com/scorpio/group/20170425/4000264810-6362872848946855461428672.pdf" target="_blank" rel="noopener">http://gfiles.chinaaet.com/scorpio/group/20170425/4000264810-6362872848946855461428672.pdf</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/wild-pig-chapter2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="梅子黄时雨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/18/wild-pig-chapter2/" class="post-title-link" itemprop="url">野猪书第二章读书笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-18 16:33:11 / Modified: 16:34:25" itemprop="dateCreated datePublished" datetime="2019-11-18T16:33:11+08:00">2019-11-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-模型"><a href="#1-模型" class="headerlink" title="1. 模型"></a>1. 模型</h3><ul>
<li>层次化模型(hierachy)<ul>
<li>树状结构 -&gt; keep one-to-many or many-to-one</li>
<li>no many-to-many</li>
</ul>
</li>
<li>关系化模型 -&gt; sql<ul>
<li>范式</li>
<li>在复杂的或者多层的one-to-many结构中需要拆成多张表</li>
</ul>
</li>
<li>文档化模型(document) -&gt; json<ul>
<li>一列中可以保存复杂结构的数据</li>
<li>比如列表形式的历史记录</li>
<li>对于不复杂的one-to-many特别适合</li>
<li>但是对于many-to-many不是那么有优势</li>
<li>join不是那么友好，许多数据库都不支持join</li>
</ul>
</li>
<li>网络化模型(network)<ul>
<li>图状结构,many-to-many</li>
<li>搜索和优化变得困难</li>
<li>图计算数据库</li>
</ul>
</li>
</ul>
<h3 id="2-存储模型"><a href="#2-存储模型" class="headerlink" title="2. 存储模型"></a>2. 存储模型</h3><p>规格化的（normalized): 所有重复的数值(主要是string)会被应设成id</p>
<ul>
<li>统一的格式和语法</li>
<li>避免歧义</li>
<li>i18n的时候分离了显示和存储要求，更加方便迁移</li>
<li>更快的search</li>
<li>[坏处]规格化的数据需要多张表，search时候需要更加多的join</li>
</ul>
<p>非规格化的(denormalized):</p>
<ul>
<li>如果数据库本身不支持join</li>
<li>可能对于cache hit更加友好</li>
</ul>
<h3 id="3-schema设计"><a href="#3-schema设计" class="headerlink" title="3. schema设计"></a>3. schema设计</h3><ul>
<li>读时schema模式（所谓无模式）：在读的时候检查需要的shchema是否合理</li>
<li>写时schema模式，在写的时候做检查，否则不让写入</li>
</ul>
<p>实际上会是混合模式，写时会做一部分，读的时候做一部分。</p>
<p>这些设计在column发生修改时候变的有所不同。</p>
<ul>
<li>读时schema可能只需要写入新的field的值就可以了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (user &amp;&amp; user.name &amp;&amp; !user.first_name) &#123;</span><br><span class="line">    user.first_name = user.name.split(&quot; &quot;)[0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写时schema需要更新数据库table的schema</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE users ADD COLUMN first_name text;</span><br><span class="line">UPDATE users SET first_name = split_part(name, &quot; &quot;, 1);    -- PostgreSQL</span><br><span class="line">UPDATE users SET first_name = substring_index(name, &quot; &quot;, 1);   -- MySQL</span><br></pre></td></tr></table></figure>
<p>schema的更新(ALTER)是件代价不小的操作，另外UPDATE操作对于大表和有复杂关联的表系列也有不小的代价。一般而言可以将新加入的field设置为NULL，在读的时候进行设置。</p>
<p>所以在这种情况下，如果数据中包含了不一致的schema结构（数据异构），例如：</p>
<ul>
<li>有许多的数据格式</li>
<li>数据系统的schema结构不稳定，会发生变动</li>
</ul>
<h3 id="4-查询的局部性"><a href="#4-查询的局部性" class="headerlink" title="4. 查询的局部性"></a>4. 查询的局部性</h3><ul>
<li>分成多张表的数据存储格式在读取连续数据时候会有一定的性能影响，需要多次索引</li>
<li>修改数据时候，最好的是原地覆盖，因此建议写入的文档尽量小，并且不增加数据大小</li>
<li>所以，为了提高局部性，可以<ul>
<li>父表内嵌入子表数据（类似json）</li>
<li>多索引集群表</li>
<li>列式存储，列簇</li>
</ul>
</li>
</ul>
<h3 id="5-数据查询语言"><a href="#5-数据查询语言" class="headerlink" title="5. 数据查询语言"></a>5. 数据查询语言</h3><ul>
<li>声明式：比如SQL，只是给出了我想要什么，给出范围，但是没有给出具体的操作流程</li>
<li>命令式：定义为完整的操作流程，执行的命令。</li>
</ul>
<p>声明式隔离了底层的实现逻辑，使得：</p>
<ul>
<li>API变的简洁和容易理解</li>
<li>提供优化的机会</li>
<li>提供并行执行的实现方式</li>
</ul>
<h3 id="6-图状数据库"><a href="#6-图状数据库" class="headerlink" title="6. 图状数据库"></a>6. 图状数据库</h3><ul>
<li>基本组成”顶点” + “边”。</li>
<li>相关算法：导航，PageRank</li>
</ul>
<p>图状数据库模型：</p>
<ul>
<li>属性图（property graph）<ul>
<li>Neon4j, Titan和InfiniteGraph </li>
</ul>
</li>
<li>三元存储模型（triple-store）<ul>
<li>Datomic, AllegroGraph</li>
</ul>
</li>
</ul>
<p>查询语句</p>
<ul>
<li>声明式查询语句：Cypher, SPARQL, Datalog</li>
<li>命令式查询语句：Gremlin</li>
<li>图处理框架: Pregel</li>
</ul>
<h4 id="6-1-属性图"><a href="#6-1-属性图" class="headerlink" title="6.1. 属性图"></a>6.1. 属性图</h4><p>在属性图模型中，一个顶点包含了：</p>
<ul>
<li>UUID</li>
<li>Input/Output edge list</li>
<li>property set (key-value pair)</li>
</ul>
<p>一个边包含了：</p>
<ul>
<li>UUID</li>
<li>edage start/end node</li>
<li>label describe relationship between start node and end node</li>
<li>property set (key-value pair)</li>
</ul>
<p>在完成这些定义后，属性图可以很方便的使用多张关系数据库表来进行存储</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> vertices (</span><br><span class="line"> vertex_id <span class="built_in">integer</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"> properties <span class="keyword">json</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> edges (</span><br><span class="line"> edge_id <span class="built_in">integer</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"> tail_vertex <span class="built_in">integer</span> <span class="keyword">REFERENCES</span> vertices (vertex_id),</span><br><span class="line"> head_vertex <span class="built_in">integer</span> <span class="keyword">REFERENCES</span> vertices (vertex_id),</span><br><span class="line"> label <span class="built_in">text</span>,</span><br><span class="line"> properties <span class="keyword">json</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> edges_tails <span class="keyword">ON</span> edges (tail_vertex);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> edges_heads <span class="keyword">ON</span> edges (head_vertex);</span><br></pre></td></tr></table></figure>
<p>属性图提供了非常强大的灵活性来描述一张图的结构。</p>
<h4 id="6-2-Cypher"><a href="#6-2-Cypher" class="headerlink" title="6.2. Cypher"></a>6.2. Cypher</h4><p>基本思路是定义一个节点或者一条边需要满足的条件，查询的具体细节不关注，比如，我们想要查询这一样一个节点（人）：</p>
<ul>
<li>person，通过节点label为BORN_IN的outgoing edge，以及系列WITH_IN outgoing edage，最终抵达某个标注为US的节点</li>
<li>person，通过节点label为LIVES_IN的outgoing edge，以及系列WITH_IN outgoing edage，抵达某个标注为US的节点</li>
</ul>
<p>最后打印出来person的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH</span><br><span class="line"> (person) -[:BORN_IN]-&gt; () -[:WITHIN*0..]-&gt; (us:Location &#123;name:&apos;United States&apos;&#125;),</span><br><span class="line"> (person) -[:LIVES_IN]-&gt; () -[:WITHIN*0..]-&gt; (eu:Location &#123;name:&apos;Europe&apos;&#125;)</span><br><span class="line">RETURN person.name</span><br></pre></td></tr></table></figure>
<p>如果用SQL来做，会成多次的表的join。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- in_usa is the set of vertex IDs of all locations within the United States</span></span><br><span class="line"> in_usa(vertex_id) <span class="keyword">AS</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> vertex_id <span class="keyword">FROM</span> vertices <span class="keyword">WHERE</span> properties-&gt;&gt;<span class="string">'name'</span> = <span class="string">'United States'</span></span><br><span class="line"> <span class="keyword">UNION</span></span><br><span class="line"> <span class="keyword">SELECT</span> edges.tail_vertex <span class="keyword">FROM</span> edges</span><br><span class="line"> <span class="keyword">JOIN</span> in_usa <span class="keyword">ON</span> edges.head_vertex = in_usa.vertex_id</span><br><span class="line"> <span class="keyword">WHERE</span> edges.label = <span class="string">'within'</span></span><br><span class="line"> ),</span><br><span class="line"> </span><br><span class="line"> <span class="comment">-- in_europe is the set of vertex IDs of all locations within Europe</span></span><br><span class="line"> in_europe(vertex_id) <span class="keyword">AS</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> vertex_id <span class="keyword">FROM</span> vertices <span class="keyword">WHERE</span> properties-&gt;&gt;<span class="string">'name'</span> = <span class="string">'Europe'</span></span><br><span class="line"> <span class="keyword">UNION</span></span><br><span class="line"> <span class="keyword">SELECT</span> edges.tail_vertex <span class="keyword">FROM</span> edges</span><br><span class="line"> <span class="keyword">JOIN</span> in_europe <span class="keyword">ON</span> edges.head_vertex = in_europe.vertex_id</span><br><span class="line"> <span class="keyword">WHERE</span> edges.label = <span class="string">'within'</span></span><br><span class="line"> ),</span><br><span class="line"> </span><br><span class="line"> <span class="comment">-- born_in_usa is the set of vertex IDs of all people born in the US</span></span><br><span class="line"> born_in_usa(vertex_id) <span class="keyword">AS</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> edges.tail_vertex <span class="keyword">FROM</span> edges</span><br><span class="line"> <span class="keyword">JOIN</span> in_usa <span class="keyword">ON</span> edges.head_vertex = in_usa.vertex_id</span><br><span class="line"> <span class="keyword">WHERE</span> edges.label = <span class="string">'born_in'</span></span><br><span class="line"> ),</span><br><span class="line"> </span><br><span class="line"> <span class="comment">-- lives_in_europe is the set of vertex IDs of all people living in Europe</span></span><br><span class="line"> lives_in_europe(vertex_id) <span class="keyword">AS</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> edges.tail_vertex <span class="keyword">FROM</span> edges</span><br><span class="line"> <span class="keyword">JOIN</span> in_europe <span class="keyword">ON</span> edges.head_vertex = in_europe.vertex_id</span><br><span class="line"> <span class="keyword">WHERE</span> edges.label = <span class="string">'lives_in'</span></span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> vertices.properties-&gt;&gt;<span class="string">'name'</span></span><br><span class="line"><span class="keyword">FROM</span> vertices</span><br><span class="line"><span class="comment">-- join to find those people who were both born in the US *and* live in Europe</span></span><br><span class="line"><span class="keyword">JOIN</span> born_in_usa <span class="keyword">ON</span> vertices.vertex_id = born_in_usa.vertex_id</span><br><span class="line"><span class="keyword">JOIN</span> lives_in_europe <span class="keyword">ON</span> vertices.vertex_id = lives_in_europe.vertex_id;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-三元存储模型（triple-store）"><a href="#6-3-三元存储模型（triple-store）" class="headerlink" title="6.3. 三元存储模型（triple-store）"></a>6.3. 三元存储模型（triple-store）</h4><p>三元存储模型和属性图类似，但是颗粒度更加细。所有的描述都是一个三维的tuple： (subject, predicate, object).</p>
<ul>
<li>subject一定是某个节点</li>
<li>predicate是一个edge或者一个属性</li>
<li>object可以是一个节点（edge）或者一个属性值（属性）</li>
</ul>
<p>比如，可以这样来描述一张图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@prefix : &lt;urn:example:&gt;.</span><br><span class="line">_:lucy a :Person.</span><br><span class="line">_:lucy :name &quot;Lucy&quot;.</span><br><span class="line">_:lucy :bornIn _:idaho.</span><br><span class="line">_:idaho a :Location.</span><br><span class="line">_:idaho :name &quot;Idaho&quot;.</span><br><span class="line">_:idaho :type &quot;state&quot;.</span><br><span class="line">_:idaho :within _:usa.</span><br><span class="line">_:usa a :Location.</span><br><span class="line">_:usa :name &quot;United States&quot;.</span><br><span class="line">_:usa :type &quot;country&quot;.</span><br><span class="line">_:usa :within _:namerica.</span><br><span class="line">_:namerica a :Location.</span><br><span class="line">_:namerica :name &quot;North America&quot;.</span><br><span class="line">_:namerica :type &quot;continent&quot;.</span><br></pre></td></tr></table></figure>
<p>可以压缩一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@prefix : &lt;urn:example:&gt;.</span><br><span class="line">_:lucy a :Person; :name &quot;Lucy&quot;; :bornIn _:idaho.</span><br><span class="line">_:idaho a :Location; :name &quot;Idaho&quot;; :type &quot;state&quot;; :within _:usa.</span><br><span class="line">_:usa a :Location; :name &quot;United States&quot;; :type &quot;country&quot;; :within _:namerica.</span><br><span class="line">_:namerica a :Location; :name &quot;North America&quot;; :type &quot;continent&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="7-其他模型"><a href="#7-其他模型" class="headerlink" title="7. 其他模型"></a>7. 其他模型</h3><ul>
<li>针对DNA（只有四个值）的基因组数据，GenBank</li>
<li>针对海量数据数据库</li>
<li>针对全文搜索的数据库</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leo Zhou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo Zhou</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
